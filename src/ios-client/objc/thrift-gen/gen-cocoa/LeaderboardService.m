/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"
#import "TObjective-C.h"
#import "TBase.h"


#import "LeaderboardService.h"

@implementation ReplyStatus

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithError_code: (int) error_code error_message_format: (NSString *) error_message_format error_message_args: (NSMutableArray *) error_message_args
{
  self = [super init];
  __error_code = error_code;
  __error_code_isset = YES;
  __error_message_format = [error_message_format retain_stub];
  __error_message_format_isset = YES;
  __error_message_args = [error_message_args retain_stub];
  __error_message_args_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"error_code"])
  {
    __error_code = [decoder decodeIntForKey: @"error_code"];
    __error_code_isset = YES;
  }
  if ([decoder containsValueForKey: @"error_message_format"])
  {
    __error_message_format = [[decoder decodeObjectForKey: @"error_message_format"] retain_stub];
    __error_message_format_isset = YES;
  }
  if ([decoder containsValueForKey: @"error_message_args"])
  {
    __error_message_args = [[decoder decodeObjectForKey: @"error_message_args"] retain_stub];
    __error_message_args_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__error_code_isset)
  {
    [encoder encodeInt: __error_code forKey: @"error_code"];
  }
  if (__error_message_format_isset)
  {
    [encoder encodeObject: __error_message_format forKey: @"error_message_format"];
  }
  if (__error_message_args_isset)
  {
    [encoder encodeObject: __error_message_args forKey: @"error_message_args"];
  }
}

- (void) dealloc
{
  [__error_message_format release_stub];
  [__error_message_args release_stub];
  [super dealloc_stub];
}

- (int) error_code {
  return __error_code;
}

- (void) setError_code: (int) error_code {
  __error_code = error_code;
  __error_code_isset = YES;
}

- (BOOL) error_codeIsSet {
  return __error_code_isset;
}

- (void) unsetError_code {
  __error_code_isset = NO;
}

- (NSString *) error_message_format {
  return [[__error_message_format retain_stub] autorelease_stub];
}

- (void) setError_message_format: (NSString *) error_message_format {
  [error_message_format retain_stub];
  [__error_message_format release_stub];
  __error_message_format = error_message_format;
  __error_message_format_isset = YES;
}

- (BOOL) error_message_formatIsSet {
  return __error_message_format_isset;
}

- (void) unsetError_message_format {
  [__error_message_format release_stub];
  __error_message_format = nil;
  __error_message_format_isset = NO;
}

- (NSMutableArray *) error_message_args {
  return [[__error_message_args retain_stub] autorelease_stub];
}

- (void) setError_message_args: (NSMutableArray *) error_message_args {
  [error_message_args retain_stub];
  [__error_message_args release_stub];
  __error_message_args = error_message_args;
  __error_message_args_isset = YES;
}

- (BOOL) error_message_argsIsSet {
  return __error_message_args_isset;
}

- (void) unsetError_message_args {
  [__error_message_args release_stub];
  __error_message_args = nil;
  __error_message_args_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setError_code: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setError_message_format: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            NSString * _elem2 = [inProtocol readString];
            [fieldValue addObject: _elem2];
          }
          [inProtocol readListEnd];
          [self setError_message_args: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ReplyStatus"];
  if (__error_code_isset) {
    [outProtocol writeFieldBeginWithName: @"error_code" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __error_code];
    [outProtocol writeFieldEnd];
  }
  if (__error_message_format_isset) {
    if (__error_message_format != nil) {
      [outProtocol writeFieldBeginWithName: @"error_message_format" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __error_message_format];
      [outProtocol writeFieldEnd];
    }
  }
  if (__error_message_args_isset) {
    if (__error_message_args != nil) {
      [outProtocol writeFieldBeginWithName: @"error_message_args" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__error_message_args count]];
        int i4;
        for (i4 = 0; i4 < [__error_message_args count]; i4++)
        {
          [outProtocol writeString: [__error_message_args objectAtIndex: i4]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ReplyStatus("];
  [ms appendString: @"error_code:"];
  [ms appendFormat: @"%i", __error_code];
  [ms appendString: @",error_message_format:"];
  [ms appendFormat: @"\"%@\"", __error_message_format];
  [ms appendString: @",error_message_args:"];
  [ms appendFormat: @"%@", __error_message_args];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation DefaultReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"DefaultReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"DefaultReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LeaderboardConnectReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status session_handle: (int32_t) session_handle user_data: (NSData *) user_data
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  __session_handle = session_handle;
  __session_handle_isset = YES;
  __user_data = [user_data retain_stub];
  __user_data_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"session_handle"])
  {
    __session_handle = [decoder decodeInt32ForKey: @"session_handle"];
    __session_handle_isset = YES;
  }
  if ([decoder containsValueForKey: @"user_data"])
  {
    __user_data = [[decoder decodeObjectForKey: @"user_data"] retain_stub];
    __user_data_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
  if (__session_handle_isset)
  {
    [encoder encodeInt32: __session_handle forKey: @"session_handle"];
  }
  if (__user_data_isset)
  {
    [encoder encodeObject: __user_data forKey: @"user_data"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [__user_data release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (int32_t) session_handle {
  return __session_handle;
}

- (void) setSession_handle: (int32_t) session_handle {
  __session_handle = session_handle;
  __session_handle_isset = YES;
}

- (BOOL) session_handleIsSet {
  return __session_handle_isset;
}

- (void) unsetSession_handle {
  __session_handle_isset = NO;
}

- (NSData *) user_data {
  return [[__user_data retain_stub] autorelease_stub];
}

- (void) setUser_data: (NSData *) user_data {
  [user_data retain_stub];
  [__user_data release_stub];
  __user_data = user_data;
  __user_data_isset = YES;
}

- (BOOL) user_dataIsSet {
  return __user_data_isset;
}

- (void) unsetUser_data {
  [__user_data release_stub];
  __user_data = nil;
  __user_data_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSession_handle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setUser_data: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"LeaderboardConnectReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__session_handle_isset) {
    [outProtocol writeFieldBeginWithName: @"session_handle" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __session_handle];
    [outProtocol writeFieldEnd];
  }
  if (__user_data_isset) {
    if (__user_data != nil) {
      [outProtocol writeFieldBeginWithName: @"user_data" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __user_data];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"LeaderboardConnectReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @",session_handle:"];
  [ms appendFormat: @"%i", __session_handle];
  [ms appendString: @",user_data:"];
  [ms appendFormat: @"\"%@\"", __user_data];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation Session

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession_handle: (int32_t) session_handle
{
  self = [super init];
  __session_handle = session_handle;
  __session_handle_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session_handle"])
  {
    __session_handle = [decoder decodeInt32ForKey: @"session_handle"];
    __session_handle_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_handle_isset)
  {
    [encoder encodeInt32: __session_handle forKey: @"session_handle"];
  }
}

- (void) dealloc
{
  [super dealloc_stub];
}

- (int32_t) session_handle {
  return __session_handle;
}

- (void) setSession_handle: (int32_t) session_handle {
  __session_handle = session_handle;
  __session_handle_isset = YES;
}

- (BOOL) session_handleIsSet {
  return __session_handle_isset;
}

- (void) unsetSession_handle {
  __session_handle_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSession_handle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Session"];
  if (__session_handle_isset) {
    [outProtocol writeFieldBeginWithName: @"session_handle" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __session_handle];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Session("];
  [ms appendString: @"session_handle:"];
  [ms appendFormat: @"%i", __session_handle];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation Score

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithValue: (int64_t) value date_epoch: (int64_t) date_epoch player_alias: (NSString *) player_alias player_id: (NSString *) player_id rank: (int32_t) rank situation: (NSData *) situation vote_up_count: (int32_t) vote_up_count vote_down_count: (int32_t) vote_down_count
{
  self = [super init];
  __value = value;
  __value_isset = YES;
  __date_epoch = date_epoch;
  __date_epoch_isset = YES;
  __player_alias = [player_alias retain_stub];
  __player_alias_isset = YES;
  __player_id = [player_id retain_stub];
  __player_id_isset = YES;
  __rank = rank;
  __rank_isset = YES;
  __situation = [situation retain_stub];
  __situation_isset = YES;
  __vote_up_count = vote_up_count;
  __vote_up_count_isset = YES;
  __vote_down_count = vote_down_count;
  __vote_down_count_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"value"])
  {
    __value = [decoder decodeInt64ForKey: @"value"];
    __value_isset = YES;
  }
  if ([decoder containsValueForKey: @"date_epoch"])
  {
    __date_epoch = [decoder decodeInt64ForKey: @"date_epoch"];
    __date_epoch_isset = YES;
  }
  if ([decoder containsValueForKey: @"player_alias"])
  {
    __player_alias = [[decoder decodeObjectForKey: @"player_alias"] retain_stub];
    __player_alias_isset = YES;
  }
  if ([decoder containsValueForKey: @"player_id"])
  {
    __player_id = [[decoder decodeObjectForKey: @"player_id"] retain_stub];
    __player_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"rank"])
  {
    __rank = [decoder decodeInt32ForKey: @"rank"];
    __rank_isset = YES;
  }
  if ([decoder containsValueForKey: @"situation"])
  {
    __situation = [[decoder decodeObjectForKey: @"situation"] retain_stub];
    __situation_isset = YES;
  }
  if ([decoder containsValueForKey: @"vote_up_count"])
  {
    __vote_up_count = [decoder decodeInt32ForKey: @"vote_up_count"];
    __vote_up_count_isset = YES;
  }
  if ([decoder containsValueForKey: @"vote_down_count"])
  {
    __vote_down_count = [decoder decodeInt32ForKey: @"vote_down_count"];
    __vote_down_count_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__value_isset)
  {
    [encoder encodeInt64: __value forKey: @"value"];
  }
  if (__date_epoch_isset)
  {
    [encoder encodeInt64: __date_epoch forKey: @"date_epoch"];
  }
  if (__player_alias_isset)
  {
    [encoder encodeObject: __player_alias forKey: @"player_alias"];
  }
  if (__player_id_isset)
  {
    [encoder encodeObject: __player_id forKey: @"player_id"];
  }
  if (__rank_isset)
  {
    [encoder encodeInt32: __rank forKey: @"rank"];
  }
  if (__situation_isset)
  {
    [encoder encodeObject: __situation forKey: @"situation"];
  }
  if (__vote_up_count_isset)
  {
    [encoder encodeInt32: __vote_up_count forKey: @"vote_up_count"];
  }
  if (__vote_down_count_isset)
  {
    [encoder encodeInt32: __vote_down_count forKey: @"vote_down_count"];
  }
}

- (void) dealloc
{
  [__player_alias release_stub];
  [__player_id release_stub];
  [__situation release_stub];
  [super dealloc_stub];
}

- (int64_t) value {
  return __value;
}

- (void) setValue: (int64_t) value {
  __value = value;
  __value_isset = YES;
}

- (BOOL) valueIsSet {
  return __value_isset;
}

- (void) unsetValue {
  __value_isset = NO;
}

- (int64_t) date_epoch {
  return __date_epoch;
}

- (void) setDate_epoch: (int64_t) date_epoch {
  __date_epoch = date_epoch;
  __date_epoch_isset = YES;
}

- (BOOL) date_epochIsSet {
  return __date_epoch_isset;
}

- (void) unsetDate_epoch {
  __date_epoch_isset = NO;
}

- (NSString *) player_alias {
  return [[__player_alias retain_stub] autorelease_stub];
}

- (void) setPlayer_alias: (NSString *) player_alias {
  [player_alias retain_stub];
  [__player_alias release_stub];
  __player_alias = player_alias;
  __player_alias_isset = YES;
}

- (BOOL) player_aliasIsSet {
  return __player_alias_isset;
}

- (void) unsetPlayer_alias {
  [__player_alias release_stub];
  __player_alias = nil;
  __player_alias_isset = NO;
}

- (NSString *) player_id {
  return [[__player_id retain_stub] autorelease_stub];
}

- (void) setPlayer_id: (NSString *) player_id {
  [player_id retain_stub];
  [__player_id release_stub];
  __player_id = player_id;
  __player_id_isset = YES;
}

- (BOOL) player_idIsSet {
  return __player_id_isset;
}

- (void) unsetPlayer_id {
  [__player_id release_stub];
  __player_id = nil;
  __player_id_isset = NO;
}

- (int32_t) rank {
  return __rank;
}

- (void) setRank: (int32_t) rank {
  __rank = rank;
  __rank_isset = YES;
}

- (BOOL) rankIsSet {
  return __rank_isset;
}

- (void) unsetRank {
  __rank_isset = NO;
}

- (NSData *) situation {
  return [[__situation retain_stub] autorelease_stub];
}

- (void) setSituation: (NSData *) situation {
  [situation retain_stub];
  [__situation release_stub];
  __situation = situation;
  __situation_isset = YES;
}

- (BOOL) situationIsSet {
  return __situation_isset;
}

- (void) unsetSituation {
  [__situation release_stub];
  __situation = nil;
  __situation_isset = NO;
}

- (int32_t) vote_up_count {
  return __vote_up_count;
}

- (void) setVote_up_count: (int32_t) vote_up_count {
  __vote_up_count = vote_up_count;
  __vote_up_count_isset = YES;
}

- (BOOL) vote_up_countIsSet {
  return __vote_up_count_isset;
}

- (void) unsetVote_up_count {
  __vote_up_count_isset = NO;
}

- (int32_t) vote_down_count {
  return __vote_down_count;
}

- (void) setVote_down_count: (int32_t) vote_down_count {
  __vote_down_count = vote_down_count;
  __vote_down_count_isset = YES;
}

- (BOOL) vote_down_countIsSet {
  return __vote_down_count_isset;
}

- (void) unsetVote_down_count {
  __vote_down_count_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setValue: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setDate_epoch: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPlayer_alias: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPlayer_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setRank: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSituation: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setVote_up_count: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setVote_down_count: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Score"];
  if (__value_isset) {
    [outProtocol writeFieldBeginWithName: @"value" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __value];
    [outProtocol writeFieldEnd];
  }
  if (__date_epoch_isset) {
    [outProtocol writeFieldBeginWithName: @"date_epoch" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __date_epoch];
    [outProtocol writeFieldEnd];
  }
  if (__player_alias_isset) {
    if (__player_alias != nil) {
      [outProtocol writeFieldBeginWithName: @"player_alias" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __player_alias];
      [outProtocol writeFieldEnd];
    }
  }
  if (__player_id_isset) {
    if (__player_id != nil) {
      [outProtocol writeFieldBeginWithName: @"player_id" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __player_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__rank_isset) {
    [outProtocol writeFieldBeginWithName: @"rank" type: TType_I32 fieldID: 5];
    [outProtocol writeI32: __rank];
    [outProtocol writeFieldEnd];
  }
  if (__situation_isset) {
    if (__situation != nil) {
      [outProtocol writeFieldBeginWithName: @"situation" type: TType_STRING fieldID: 6];
      [outProtocol writeBinary: __situation];
      [outProtocol writeFieldEnd];
    }
  }
  if (__vote_up_count_isset) {
    [outProtocol writeFieldBeginWithName: @"vote_up_count" type: TType_I32 fieldID: 7];
    [outProtocol writeI32: __vote_up_count];
    [outProtocol writeFieldEnd];
  }
  if (__vote_down_count_isset) {
    [outProtocol writeFieldBeginWithName: @"vote_down_count" type: TType_I32 fieldID: 8];
    [outProtocol writeI32: __vote_down_count];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Score("];
  [ms appendString: @"value:"];
  [ms appendFormat: @"%qi", __value];
  [ms appendString: @",date_epoch:"];
  [ms appendFormat: @"%qi", __date_epoch];
  [ms appendString: @",player_alias:"];
  [ms appendFormat: @"\"%@\"", __player_alias];
  [ms appendString: @",player_id:"];
  [ms appendFormat: @"\"%@\"", __player_id];
  [ms appendString: @",rank:"];
  [ms appendFormat: @"%i", __rank];
  [ms appendString: @",situation:"];
  [ms appendFormat: @"\"%@\"", __situation];
  [ms appendString: @",vote_up_count:"];
  [ms appendFormat: @"%i", __vote_up_count];
  [ms appendString: @",vote_down_count:"];
  [ms appendFormat: @"%i", __vote_down_count];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation GetScoresReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithPlayer_score: (Score *) player_score from_rank: (int32_t) from_rank count: (int64_t) count top_scores: (NSMutableArray *) top_scores
{
  self = [super init];
  __player_score = [player_score retain_stub];
  __player_score_isset = YES;
  __from_rank = from_rank;
  __from_rank_isset = YES;
  __count = count;
  __count_isset = YES;
  __top_scores = [top_scores retain_stub];
  __top_scores_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"player_score"])
  {
    __player_score = [[decoder decodeObjectForKey: @"player_score"] retain_stub];
    __player_score_isset = YES;
  }
  if ([decoder containsValueForKey: @"from_rank"])
  {
    __from_rank = [decoder decodeInt32ForKey: @"from_rank"];
    __from_rank_isset = YES;
  }
  if ([decoder containsValueForKey: @"count"])
  {
    __count = [decoder decodeInt64ForKey: @"count"];
    __count_isset = YES;
  }
  if ([decoder containsValueForKey: @"top_scores"])
  {
    __top_scores = [[decoder decodeObjectForKey: @"top_scores"] retain_stub];
    __top_scores_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__player_score_isset)
  {
    [encoder encodeObject: __player_score forKey: @"player_score"];
  }
  if (__from_rank_isset)
  {
    [encoder encodeInt32: __from_rank forKey: @"from_rank"];
  }
  if (__count_isset)
  {
    [encoder encodeInt64: __count forKey: @"count"];
  }
  if (__top_scores_isset)
  {
    [encoder encodeObject: __top_scores forKey: @"top_scores"];
  }
}

- (void) dealloc
{
  [__player_score release_stub];
  [__top_scores release_stub];
  [super dealloc_stub];
}

- (Score *) player_score {
  return [[__player_score retain_stub] autorelease_stub];
}

- (void) setPlayer_score: (Score *) player_score {
  [player_score retain_stub];
  [__player_score release_stub];
  __player_score = player_score;
  __player_score_isset = YES;
}

- (BOOL) player_scoreIsSet {
  return __player_score_isset;
}

- (void) unsetPlayer_score {
  [__player_score release_stub];
  __player_score = nil;
  __player_score_isset = NO;
}

- (int32_t) from_rank {
  return __from_rank;
}

- (void) setFrom_rank: (int32_t) from_rank {
  __from_rank = from_rank;
  __from_rank_isset = YES;
}

- (BOOL) from_rankIsSet {
  return __from_rank_isset;
}

- (void) unsetFrom_rank {
  __from_rank_isset = NO;
}

- (int64_t) count {
  return __count;
}

- (void) setCount: (int64_t) count {
  __count = count;
  __count_isset = YES;
}

- (BOOL) countIsSet {
  return __count_isset;
}

- (void) unsetCount {
  __count_isset = NO;
}

- (NSMutableArray *) top_scores {
  return [[__top_scores retain_stub] autorelease_stub];
}

- (void) setTop_scores: (NSMutableArray *) top_scores {
  [top_scores retain_stub];
  [__top_scores release_stub];
  __top_scores = top_scores;
  __top_scores_isset = YES;
}

- (BOOL) top_scoresIsSet {
  return __top_scores_isset;
}

- (void) unsetTop_scores {
  [__top_scores release_stub];
  __top_scores = nil;
  __top_scores_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Score *fieldValue = [[Score alloc] init];
          [fieldValue read: inProtocol];
          [self setPlayer_score: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setFrom_rank: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size5;
          [inProtocol readListBeginReturningElementType: NULL size: &_size5];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size5];
          int _i6;
          for (_i6 = 0; _i6 < _size5; ++_i6)
          {
            Score *_elem7 = [[Score alloc] init];
            [_elem7 read: inProtocol];
            [fieldValue addObject: _elem7];
            [_elem7 release_stub];
          }
          [inProtocol readListEnd];
          [self setTop_scores: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetScoresReply"];
  if (__player_score_isset) {
    if (__player_score != nil) {
      [outProtocol writeFieldBeginWithName: @"player_score" type: TType_STRUCT fieldID: 1];
      [__player_score write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__from_rank_isset) {
    [outProtocol writeFieldBeginWithName: @"from_rank" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __from_rank];
    [outProtocol writeFieldEnd];
  }
  if (__count_isset) {
    [outProtocol writeFieldBeginWithName: @"count" type: TType_I64 fieldID: 3];
    [outProtocol writeI64: __count];
    [outProtocol writeFieldEnd];
  }
  if (__top_scores_isset) {
    if (__top_scores != nil) {
      [outProtocol writeFieldBeginWithName: @"top_scores" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__top_scores count]];
        int i9;
        for (i9 = 0; i9 < [__top_scores count]; i9++)
        {
          [[__top_scores objectAtIndex: i9] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetScoresReply("];
  [ms appendString: @"player_score:"];
  [ms appendFormat: @"%@", __player_score];
  [ms appendString: @",from_rank:"];
  [ms appendFormat: @"%i", __from_rank];
  [ms appendString: @",count:"];
  [ms appendFormat: @"%qi", __count];
  [ms appendString: @",top_scores:"];
  [ms appendFormat: @"%@", __top_scores];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation PostScoreReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status scores: (GetScoresReply *) scores
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  __scores = [scores retain_stub];
  __scores_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"scores"])
  {
    __scores = [[decoder decodeObjectForKey: @"scores"] retain_stub];
    __scores_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
  if (__scores_isset)
  {
    [encoder encodeObject: __scores forKey: @"scores"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [__scores release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (GetScoresReply *) scores {
  return [[__scores retain_stub] autorelease_stub];
}

- (void) setScores: (GetScoresReply *) scores {
  [scores retain_stub];
  [__scores release_stub];
  __scores = scores;
  __scores_isset = YES;
}

- (BOOL) scoresIsSet {
  return __scores_isset;
}

- (void) unsetScores {
  [__scores release_stub];
  __scores = nil;
  __scores_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          GetScoresReply *fieldValue = [[GetScoresReply alloc] init];
          [fieldValue read: inProtocol];
          [self setScores: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"PostScoreReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__scores_isset) {
    if (__scores != nil) {
      [outProtocol writeFieldBeginWithName: @"scores" type: TType_STRUCT fieldID: 2];
      [__scores write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"PostScoreReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @",scores:"];
  [ms appendFormat: @"%@", __scores];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation ConnectReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status server_name: (NSString *) server_name session_handle: (int32_t) session_handle user_data: (NSData *) user_data
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  __server_name = [server_name retain_stub];
  __server_name_isset = YES;
  __session_handle = session_handle;
  __session_handle_isset = YES;
  __user_data = [user_data retain_stub];
  __user_data_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"server_name"])
  {
    __server_name = [[decoder decodeObjectForKey: @"server_name"] retain_stub];
    __server_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"session_handle"])
  {
    __session_handle = [decoder decodeInt32ForKey: @"session_handle"];
    __session_handle_isset = YES;
  }
  if ([decoder containsValueForKey: @"user_data"])
  {
    __user_data = [[decoder decodeObjectForKey: @"user_data"] retain_stub];
    __user_data_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
  if (__server_name_isset)
  {
    [encoder encodeObject: __server_name forKey: @"server_name"];
  }
  if (__session_handle_isset)
  {
    [encoder encodeInt32: __session_handle forKey: @"session_handle"];
  }
  if (__user_data_isset)
  {
    [encoder encodeObject: __user_data forKey: @"user_data"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [__server_name release_stub];
  [__user_data release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (NSString *) server_name {
  return [[__server_name retain_stub] autorelease_stub];
}

- (void) setServer_name: (NSString *) server_name {
  [server_name retain_stub];
  [__server_name release_stub];
  __server_name = server_name;
  __server_name_isset = YES;
}

- (BOOL) server_nameIsSet {
  return __server_name_isset;
}

- (void) unsetServer_name {
  [__server_name release_stub];
  __server_name = nil;
  __server_name_isset = NO;
}

- (int32_t) session_handle {
  return __session_handle;
}

- (void) setSession_handle: (int32_t) session_handle {
  __session_handle = session_handle;
  __session_handle_isset = YES;
}

- (BOOL) session_handleIsSet {
  return __session_handle_isset;
}

- (void) unsetSession_handle {
  __session_handle_isset = NO;
}

- (NSData *) user_data {
  return [[__user_data retain_stub] autorelease_stub];
}

- (void) setUser_data: (NSData *) user_data {
  [user_data retain_stub];
  [__user_data release_stub];
  __user_data = user_data;
  __user_data_isset = YES;
}

- (BOOL) user_dataIsSet {
  return __user_data_isset;
}

- (void) unsetUser_data {
  [__user_data release_stub];
  __user_data = nil;
  __user_data_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setServer_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSession_handle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setUser_data: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ConnectReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__server_name_isset) {
    if (__server_name != nil) {
      [outProtocol writeFieldBeginWithName: @"server_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __server_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__session_handle_isset) {
    [outProtocol writeFieldBeginWithName: @"session_handle" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __session_handle];
    [outProtocol writeFieldEnd];
  }
  if (__user_data_isset) {
    if (__user_data != nil) {
      [outProtocol writeFieldBeginWithName: @"user_data" type: TType_STRING fieldID: 4];
      [outProtocol writeBinary: __user_data];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ConnectReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @",server_name:"];
  [ms appendFormat: @"\"%@\"", __server_name];
  [ms appendString: @",session_handle:"];
  [ms appendFormat: @"%i", __session_handle];
  [ms appendString: @",user_data:"];
  [ms appendFormat: @"\"%@\"", __user_data];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

static int32_t PROTOCOL_VERSION = 1;

@implementation LeaderboardServiceConstants
+ (void) initialize {
}
+ (int32_t) PROTOCOL_VERSION{
  return PROTOCOL_VERSION;
}
@end

@interface connect_args : NSObject <TBase, NSCoding> {
  int32_t __protocol_version;
  NSString * __player_id;
  NSString * __player_password;
  NSData * __user_data;

  BOOL __protocol_version_isset;
  BOOL __player_id_isset;
  BOOL __player_password_isset;
  BOOL __user_data_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=protocol_version, setter=setProtocol_version:) int32_t protocol_version;
@property (nonatomic, retain, getter=player_id, setter=setPlayer_id:) NSString * player_id;
@property (nonatomic, retain, getter=player_password, setter=setPlayer_password:) NSString * player_password;
@property (nonatomic, retain, getter=user_data, setter=setUser_data:) NSData * user_data;
#endif

- (id) init;
- (id) initWithProtocol_version: (int32_t) protocol_version player_id: (NSString *) player_id player_password: (NSString *) player_password user_data: (NSData *) user_data;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (int32_t) protocol_version;
- (void) setProtocol_version: (int32_t) protocol_version;
#endif
- (BOOL) protocol_versionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) player_id;
- (void) setPlayer_id: (NSString *) player_id;
#endif
- (BOOL) player_idIsSet;

#if !__has_feature(objc_arc)
- (NSString *) player_password;
- (void) setPlayer_password: (NSString *) player_password;
#endif
- (BOOL) player_passwordIsSet;

#if !__has_feature(objc_arc)
- (NSData *) user_data;
- (void) setUser_data: (NSData *) user_data;
#endif
- (BOOL) user_dataIsSet;

@end

@implementation connect_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithProtocol_version: (int32_t) protocol_version player_id: (NSString *) player_id player_password: (NSString *) player_password user_data: (NSData *) user_data
{
  self = [super init];
  __protocol_version = protocol_version;
  __protocol_version_isset = YES;
  __player_id = [player_id retain_stub];
  __player_id_isset = YES;
  __player_password = [player_password retain_stub];
  __player_password_isset = YES;
  __user_data = [user_data retain_stub];
  __user_data_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"protocol_version"])
  {
    __protocol_version = [decoder decodeInt32ForKey: @"protocol_version"];
    __protocol_version_isset = YES;
  }
  if ([decoder containsValueForKey: @"player_id"])
  {
    __player_id = [[decoder decodeObjectForKey: @"player_id"] retain_stub];
    __player_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"player_password"])
  {
    __player_password = [[decoder decodeObjectForKey: @"player_password"] retain_stub];
    __player_password_isset = YES;
  }
  if ([decoder containsValueForKey: @"user_data"])
  {
    __user_data = [[decoder decodeObjectForKey: @"user_data"] retain_stub];
    __user_data_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__protocol_version_isset)
  {
    [encoder encodeInt32: __protocol_version forKey: @"protocol_version"];
  }
  if (__player_id_isset)
  {
    [encoder encodeObject: __player_id forKey: @"player_id"];
  }
  if (__player_password_isset)
  {
    [encoder encodeObject: __player_password forKey: @"player_password"];
  }
  if (__user_data_isset)
  {
    [encoder encodeObject: __user_data forKey: @"user_data"];
  }
}

- (void) dealloc
{
  [__player_id release_stub];
  [__player_password release_stub];
  [__user_data release_stub];
  [super dealloc_stub];
}

- (int32_t) protocol_version {
  return __protocol_version;
}

- (void) setProtocol_version: (int32_t) protocol_version {
  __protocol_version = protocol_version;
  __protocol_version_isset = YES;
}

- (BOOL) protocol_versionIsSet {
  return __protocol_version_isset;
}

- (void) unsetProtocol_version {
  __protocol_version_isset = NO;
}

- (NSString *) player_id {
  return [[__player_id retain_stub] autorelease_stub];
}

- (void) setPlayer_id: (NSString *) player_id {
  [player_id retain_stub];
  [__player_id release_stub];
  __player_id = player_id;
  __player_id_isset = YES;
}

- (BOOL) player_idIsSet {
  return __player_id_isset;
}

- (void) unsetPlayer_id {
  [__player_id release_stub];
  __player_id = nil;
  __player_id_isset = NO;
}

- (NSString *) player_password {
  return [[__player_password retain_stub] autorelease_stub];
}

- (void) setPlayer_password: (NSString *) player_password {
  [player_password retain_stub];
  [__player_password release_stub];
  __player_password = player_password;
  __player_password_isset = YES;
}

- (BOOL) player_passwordIsSet {
  return __player_password_isset;
}

- (void) unsetPlayer_password {
  [__player_password release_stub];
  __player_password = nil;
  __player_password_isset = NO;
}

- (NSData *) user_data {
  return [[__user_data retain_stub] autorelease_stub];
}

- (void) setUser_data: (NSData *) user_data {
  [user_data retain_stub];
  [__user_data release_stub];
  __user_data = user_data;
  __user_data_isset = YES;
}

- (BOOL) user_dataIsSet {
  return __user_data_isset;
}

- (void) unsetUser_data {
  [__user_data release_stub];
  __user_data = nil;
  __user_data_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setProtocol_version: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPlayer_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPlayer_password: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setUser_data: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"connect_args"];
  if (__protocol_version_isset) {
    [outProtocol writeFieldBeginWithName: @"protocol_version" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __protocol_version];
    [outProtocol writeFieldEnd];
  }
  if (__player_id_isset) {
    if (__player_id != nil) {
      [outProtocol writeFieldBeginWithName: @"player_id" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __player_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__player_password_isset) {
    if (__player_password != nil) {
      [outProtocol writeFieldBeginWithName: @"player_password" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __player_password];
      [outProtocol writeFieldEnd];
    }
  }
  if (__user_data_isset) {
    if (__user_data != nil) {
      [outProtocol writeFieldBeginWithName: @"user_data" type: TType_STRING fieldID: 4];
      [outProtocol writeBinary: __user_data];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"connect_args("];
  [ms appendString: @"protocol_version:"];
  [ms appendFormat: @"%i", __protocol_version];
  [ms appendString: @",player_id:"];
  [ms appendFormat: @"\"%@\"", __player_id];
  [ms appendString: @",player_password:"];
  [ms appendFormat: @"\"%@\"", __player_password];
  [ms appendString: @",user_data:"];
  [ms appendFormat: @"\"%@\"", __user_data];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Connect_result : NSObject <TBase, NSCoding> {
  ConnectReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) ConnectReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (ConnectReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (ConnectReply *) success;
- (void) setSuccess: (ConnectReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Connect_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (ConnectReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (ConnectReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (ConnectReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          ConnectReply *fieldValue = [[ConnectReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Connect_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Connect_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface disconnect_args : NSObject <TBase, NSCoding> {
  Session * __session;

  BOOL __session_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
#endif

- (id) init;
- (id) initWithSession: (Session *) session;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

@end

@implementation disconnect_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"disconnect_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"disconnect_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Disconnect_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Disconnect_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Disconnect_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Disconnect_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface post_score_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __category;
  Score * __score;

  BOOL __session_isset;
  BOOL __category_isset;
  BOOL __score_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=category, setter=setCategory:) NSString * category;
@property (nonatomic, retain, getter=score, setter=setScore:) Score * score;
#endif

- (id) init;
- (id) initWithSession: (Session *) session category: (NSString *) category score: (Score *) score;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) category;
- (void) setCategory: (NSString *) category;
#endif
- (BOOL) categoryIsSet;

#if !__has_feature(objc_arc)
- (Score *) score;
- (void) setScore: (Score *) score;
#endif
- (BOOL) scoreIsSet;

@end

@implementation post_score_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session category: (NSString *) category score: (Score *) score
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __category = [category retain_stub];
  __category_isset = YES;
  __score = [score retain_stub];
  __score_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"category"])
  {
    __category = [[decoder decodeObjectForKey: @"category"] retain_stub];
    __category_isset = YES;
  }
  if ([decoder containsValueForKey: @"score"])
  {
    __score = [[decoder decodeObjectForKey: @"score"] retain_stub];
    __score_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__category_isset)
  {
    [encoder encodeObject: __category forKey: @"category"];
  }
  if (__score_isset)
  {
    [encoder encodeObject: __score forKey: @"score"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__category release_stub];
  [__score release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) category {
  return [[__category retain_stub] autorelease_stub];
}

- (void) setCategory: (NSString *) category {
  [category retain_stub];
  [__category release_stub];
  __category = category;
  __category_isset = YES;
}

- (BOOL) categoryIsSet {
  return __category_isset;
}

- (void) unsetCategory {
  [__category release_stub];
  __category = nil;
  __category_isset = NO;
}

- (Score *) score {
  return [[__score retain_stub] autorelease_stub];
}

- (void) setScore: (Score *) score {
  [score retain_stub];
  [__score release_stub];
  __score = score;
  __score_isset = YES;
}

- (BOOL) scoreIsSet {
  return __score_isset;
}

- (void) unsetScore {
  [__score release_stub];
  __score = nil;
  __score_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setCategory: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          Score *fieldValue = [[Score alloc] init];
          [fieldValue read: inProtocol];
          [self setScore: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"post_score_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__category_isset) {
    if (__category != nil) {
      [outProtocol writeFieldBeginWithName: @"category" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __category];
      [outProtocol writeFieldEnd];
    }
  }
  if (__score_isset) {
    if (__score != nil) {
      [outProtocol writeFieldBeginWithName: @"score" type: TType_STRUCT fieldID: 3];
      [__score write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"post_score_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",category:"];
  [ms appendFormat: @"\"%@\"", __category];
  [ms appendString: @",score:"];
  [ms appendFormat: @"%@", __score];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Post_score_result : NSObject <TBase, NSCoding> {
  PostScoreReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) PostScoreReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (PostScoreReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (PostScoreReply *) success;
- (void) setSuccess: (PostScoreReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Post_score_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (PostScoreReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (PostScoreReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (PostScoreReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          PostScoreReply *fieldValue = [[PostScoreReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Post_score_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Post_score_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface get_scores_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __categoy;
  NSString * __player_id;
  int32_t __from_rank;
  int64_t __count;

  BOOL __session_isset;
  BOOL __categoy_isset;
  BOOL __player_id_isset;
  BOOL __from_rank_isset;
  BOOL __count_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=categoy, setter=setCategoy:) NSString * categoy;
@property (nonatomic, retain, getter=player_id, setter=setPlayer_id:) NSString * player_id;
@property (nonatomic, getter=from_rank, setter=setFrom_rank:) int32_t from_rank;
@property (nonatomic, getter=count, setter=setCount:) int64_t count;
#endif

- (id) init;
- (id) initWithSession: (Session *) session categoy: (NSString *) categoy player_id: (NSString *) player_id from_rank: (int32_t) from_rank count: (int64_t) count;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) categoy;
- (void) setCategoy: (NSString *) categoy;
#endif
- (BOOL) categoyIsSet;

#if !__has_feature(objc_arc)
- (NSString *) player_id;
- (void) setPlayer_id: (NSString *) player_id;
#endif
- (BOOL) player_idIsSet;

#if !__has_feature(objc_arc)
- (int32_t) from_rank;
- (void) setFrom_rank: (int32_t) from_rank;
#endif
- (BOOL) from_rankIsSet;

#if !__has_feature(objc_arc)
- (int64_t) count;
- (void) setCount: (int64_t) count;
#endif
- (BOOL) countIsSet;

@end

@implementation get_scores_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session categoy: (NSString *) categoy player_id: (NSString *) player_id from_rank: (int32_t) from_rank count: (int64_t) count
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __categoy = [categoy retain_stub];
  __categoy_isset = YES;
  __player_id = [player_id retain_stub];
  __player_id_isset = YES;
  __from_rank = from_rank;
  __from_rank_isset = YES;
  __count = count;
  __count_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"categoy"])
  {
    __categoy = [[decoder decodeObjectForKey: @"categoy"] retain_stub];
    __categoy_isset = YES;
  }
  if ([decoder containsValueForKey: @"player_id"])
  {
    __player_id = [[decoder decodeObjectForKey: @"player_id"] retain_stub];
    __player_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"from_rank"])
  {
    __from_rank = [decoder decodeInt32ForKey: @"from_rank"];
    __from_rank_isset = YES;
  }
  if ([decoder containsValueForKey: @"count"])
  {
    __count = [decoder decodeInt64ForKey: @"count"];
    __count_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__categoy_isset)
  {
    [encoder encodeObject: __categoy forKey: @"categoy"];
  }
  if (__player_id_isset)
  {
    [encoder encodeObject: __player_id forKey: @"player_id"];
  }
  if (__from_rank_isset)
  {
    [encoder encodeInt32: __from_rank forKey: @"from_rank"];
  }
  if (__count_isset)
  {
    [encoder encodeInt64: __count forKey: @"count"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__categoy release_stub];
  [__player_id release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) categoy {
  return [[__categoy retain_stub] autorelease_stub];
}

- (void) setCategoy: (NSString *) categoy {
  [categoy retain_stub];
  [__categoy release_stub];
  __categoy = categoy;
  __categoy_isset = YES;
}

- (BOOL) categoyIsSet {
  return __categoy_isset;
}

- (void) unsetCategoy {
  [__categoy release_stub];
  __categoy = nil;
  __categoy_isset = NO;
}

- (NSString *) player_id {
  return [[__player_id retain_stub] autorelease_stub];
}

- (void) setPlayer_id: (NSString *) player_id {
  [player_id retain_stub];
  [__player_id release_stub];
  __player_id = player_id;
  __player_id_isset = YES;
}

- (BOOL) player_idIsSet {
  return __player_id_isset;
}

- (void) unsetPlayer_id {
  [__player_id release_stub];
  __player_id = nil;
  __player_id_isset = NO;
}

- (int32_t) from_rank {
  return __from_rank;
}

- (void) setFrom_rank: (int32_t) from_rank {
  __from_rank = from_rank;
  __from_rank_isset = YES;
}

- (BOOL) from_rankIsSet {
  return __from_rank_isset;
}

- (void) unsetFrom_rank {
  __from_rank_isset = NO;
}

- (int64_t) count {
  return __count;
}

- (void) setCount: (int64_t) count {
  __count = count;
  __count_isset = YES;
}

- (BOOL) countIsSet {
  return __count_isset;
}

- (void) unsetCount {
  __count_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setCategoy: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPlayer_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setFrom_rank: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"get_scores_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__categoy_isset) {
    if (__categoy != nil) {
      [outProtocol writeFieldBeginWithName: @"categoy" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __categoy];
      [outProtocol writeFieldEnd];
    }
  }
  if (__player_id_isset) {
    if (__player_id != nil) {
      [outProtocol writeFieldBeginWithName: @"player_id" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __player_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__from_rank_isset) {
    [outProtocol writeFieldBeginWithName: @"from_rank" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __from_rank];
    [outProtocol writeFieldEnd];
  }
  if (__count_isset) {
    [outProtocol writeFieldBeginWithName: @"count" type: TType_I64 fieldID: 5];
    [outProtocol writeI64: __count];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"get_scores_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",categoy:"];
  [ms appendFormat: @"\"%@\"", __categoy];
  [ms appendString: @",player_id:"];
  [ms appendFormat: @"\"%@\"", __player_id];
  [ms appendString: @",from_rank:"];
  [ms appendFormat: @"%i", __from_rank];
  [ms appendString: @",count:"];
  [ms appendFormat: @"%qi", __count];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Get_scores_result : NSObject <TBase, NSCoding> {
  GetScoresReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) GetScoresReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (GetScoresReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (GetScoresReply *) success;
- (void) setSuccess: (GetScoresReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Get_scores_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (GetScoresReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (GetScoresReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (GetScoresReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          GetScoresReply *fieldValue = [[GetScoresReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Get_scores_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Get_scores_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface vote_score_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __voting_player_id;
  int64_t __score_value;
  int64_t __score_date_epoch;
  int32_t __vote_up_down;
  NSString * __comment;

  BOOL __session_isset;
  BOOL __voting_player_id_isset;
  BOOL __score_value_isset;
  BOOL __score_date_epoch_isset;
  BOOL __vote_up_down_isset;
  BOOL __comment_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=voting_player_id, setter=setVoting_player_id:) NSString * voting_player_id;
@property (nonatomic, getter=score_value, setter=setScore_value:) int64_t score_value;
@property (nonatomic, getter=score_date_epoch, setter=setScore_date_epoch:) int64_t score_date_epoch;
@property (nonatomic, getter=vote_up_down, setter=setVote_up_down:) int32_t vote_up_down;
@property (nonatomic, retain, getter=comment, setter=setComment:) NSString * comment;
#endif

- (id) init;
- (id) initWithSession: (Session *) session voting_player_id: (NSString *) voting_player_id score_value: (int64_t) score_value score_date_epoch: (int64_t) score_date_epoch vote_up_down: (int32_t) vote_up_down comment: (NSString *) comment;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) voting_player_id;
- (void) setVoting_player_id: (NSString *) voting_player_id;
#endif
- (BOOL) voting_player_idIsSet;

#if !__has_feature(objc_arc)
- (int64_t) score_value;
- (void) setScore_value: (int64_t) score_value;
#endif
- (BOOL) score_valueIsSet;

#if !__has_feature(objc_arc)
- (int64_t) score_date_epoch;
- (void) setScore_date_epoch: (int64_t) score_date_epoch;
#endif
- (BOOL) score_date_epochIsSet;

#if !__has_feature(objc_arc)
- (int32_t) vote_up_down;
- (void) setVote_up_down: (int32_t) vote_up_down;
#endif
- (BOOL) vote_up_downIsSet;

#if !__has_feature(objc_arc)
- (NSString *) comment;
- (void) setComment: (NSString *) comment;
#endif
- (BOOL) commentIsSet;

@end

@implementation vote_score_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session voting_player_id: (NSString *) voting_player_id score_value: (int64_t) score_value score_date_epoch: (int64_t) score_date_epoch vote_up_down: (int32_t) vote_up_down comment: (NSString *) comment
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __voting_player_id = [voting_player_id retain_stub];
  __voting_player_id_isset = YES;
  __score_value = score_value;
  __score_value_isset = YES;
  __score_date_epoch = score_date_epoch;
  __score_date_epoch_isset = YES;
  __vote_up_down = vote_up_down;
  __vote_up_down_isset = YES;
  __comment = [comment retain_stub];
  __comment_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"voting_player_id"])
  {
    __voting_player_id = [[decoder decodeObjectForKey: @"voting_player_id"] retain_stub];
    __voting_player_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"score_value"])
  {
    __score_value = [decoder decodeInt64ForKey: @"score_value"];
    __score_value_isset = YES;
  }
  if ([decoder containsValueForKey: @"score_date_epoch"])
  {
    __score_date_epoch = [decoder decodeInt64ForKey: @"score_date_epoch"];
    __score_date_epoch_isset = YES;
  }
  if ([decoder containsValueForKey: @"vote_up_down"])
  {
    __vote_up_down = [decoder decodeInt32ForKey: @"vote_up_down"];
    __vote_up_down_isset = YES;
  }
  if ([decoder containsValueForKey: @"comment"])
  {
    __comment = [[decoder decodeObjectForKey: @"comment"] retain_stub];
    __comment_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__voting_player_id_isset)
  {
    [encoder encodeObject: __voting_player_id forKey: @"voting_player_id"];
  }
  if (__score_value_isset)
  {
    [encoder encodeInt64: __score_value forKey: @"score_value"];
  }
  if (__score_date_epoch_isset)
  {
    [encoder encodeInt64: __score_date_epoch forKey: @"score_date_epoch"];
  }
  if (__vote_up_down_isset)
  {
    [encoder encodeInt32: __vote_up_down forKey: @"vote_up_down"];
  }
  if (__comment_isset)
  {
    [encoder encodeObject: __comment forKey: @"comment"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__voting_player_id release_stub];
  [__comment release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) voting_player_id {
  return [[__voting_player_id retain_stub] autorelease_stub];
}

- (void) setVoting_player_id: (NSString *) voting_player_id {
  [voting_player_id retain_stub];
  [__voting_player_id release_stub];
  __voting_player_id = voting_player_id;
  __voting_player_id_isset = YES;
}

- (BOOL) voting_player_idIsSet {
  return __voting_player_id_isset;
}

- (void) unsetVoting_player_id {
  [__voting_player_id release_stub];
  __voting_player_id = nil;
  __voting_player_id_isset = NO;
}

- (int64_t) score_value {
  return __score_value;
}

- (void) setScore_value: (int64_t) score_value {
  __score_value = score_value;
  __score_value_isset = YES;
}

- (BOOL) score_valueIsSet {
  return __score_value_isset;
}

- (void) unsetScore_value {
  __score_value_isset = NO;
}

- (int64_t) score_date_epoch {
  return __score_date_epoch;
}

- (void) setScore_date_epoch: (int64_t) score_date_epoch {
  __score_date_epoch = score_date_epoch;
  __score_date_epoch_isset = YES;
}

- (BOOL) score_date_epochIsSet {
  return __score_date_epoch_isset;
}

- (void) unsetScore_date_epoch {
  __score_date_epoch_isset = NO;
}

- (int32_t) vote_up_down {
  return __vote_up_down;
}

- (void) setVote_up_down: (int32_t) vote_up_down {
  __vote_up_down = vote_up_down;
  __vote_up_down_isset = YES;
}

- (BOOL) vote_up_downIsSet {
  return __vote_up_down_isset;
}

- (void) unsetVote_up_down {
  __vote_up_down_isset = NO;
}

- (NSString *) comment {
  return [[__comment retain_stub] autorelease_stub];
}

- (void) setComment: (NSString *) comment {
  [comment retain_stub];
  [__comment release_stub];
  __comment = comment;
  __comment_isset = YES;
}

- (BOOL) commentIsSet {
  return __comment_isset;
}

- (void) unsetComment {
  [__comment release_stub];
  __comment = nil;
  __comment_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setVoting_player_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setScore_value: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setScore_date_epoch: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setVote_up_down: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setComment: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"vote_score_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__voting_player_id_isset) {
    if (__voting_player_id != nil) {
      [outProtocol writeFieldBeginWithName: @"voting_player_id" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __voting_player_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__score_value_isset) {
    [outProtocol writeFieldBeginWithName: @"score_value" type: TType_I64 fieldID: 3];
    [outProtocol writeI64: __score_value];
    [outProtocol writeFieldEnd];
  }
  if (__score_date_epoch_isset) {
    [outProtocol writeFieldBeginWithName: @"score_date_epoch" type: TType_I64 fieldID: 4];
    [outProtocol writeI64: __score_date_epoch];
    [outProtocol writeFieldEnd];
  }
  if (__vote_up_down_isset) {
    [outProtocol writeFieldBeginWithName: @"vote_up_down" type: TType_I32 fieldID: 5];
    [outProtocol writeI32: __vote_up_down];
    [outProtocol writeFieldEnd];
  }
  if (__comment_isset) {
    if (__comment != nil) {
      [outProtocol writeFieldBeginWithName: @"comment" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __comment];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"vote_score_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",voting_player_id:"];
  [ms appendFormat: @"\"%@\"", __voting_player_id];
  [ms appendString: @",score_value:"];
  [ms appendFormat: @"%qi", __score_value];
  [ms appendString: @",score_date_epoch:"];
  [ms appendFormat: @"%qi", __score_date_epoch];
  [ms appendString: @",vote_up_down:"];
  [ms appendFormat: @"%i", __vote_up_down];
  [ms appendString: @",comment:"];
  [ms appendFormat: @"\"%@\"", __comment];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Vote_score_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Vote_score_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Vote_score_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Vote_score_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LeaderboardServiceClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  self = [super init];
  inProtocol = [anInProtocol retain_stub];
  outProtocol = [anOutProtocol retain_stub];
  return self;
}

- (void) dealloc
{
  [inProtocol release_stub];
  [outProtocol release_stub];
  [super dealloc_stub];
}

- (void) send_connect: (int32_t) protocol_version player_id: (NSString *) player_id player_password: (NSString *) player_password user_data: (NSData *) user_data
{
  [outProtocol writeMessageBeginWithName: @"connect" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"connect_args"];
  [outProtocol writeFieldBeginWithName: @"protocol_version" type: TType_I32 fieldID: 1];
  [outProtocol writeI32: protocol_version];
  [outProtocol writeFieldEnd];
  if (player_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"player_id" type: TType_STRING fieldID: 2];
    [outProtocol writeString: player_id];
    [outProtocol writeFieldEnd];
  }
  if (player_password != nil)  {
    [outProtocol writeFieldBeginWithName: @"player_password" type: TType_STRING fieldID: 3];
    [outProtocol writeString: player_password];
    [outProtocol writeFieldEnd];
  }
  if (user_data != nil)  {
    [outProtocol writeFieldBeginWithName: @"user_data" type: TType_STRING fieldID: 4];
    [outProtocol writeBinary: user_data];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (ConnectReply *) recv_connect
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Connect_result * result = [[[Connect_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"connect failed: unknown result"];
}

- (ConnectReply *) connect: (int32_t) protocol_version player_id: (NSString *) player_id player_password: (NSString *) player_password user_data: (NSData *) user_data
{
  [self send_connect : protocol_version player_id: player_id player_password: player_password user_data: user_data];
  return [self recv_connect];
}

- (void) send_disconnect: (Session *) session
{
  [outProtocol writeMessageBeginWithName: @"disconnect" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"disconnect_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_disconnect
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Disconnect_result * result = [[[Disconnect_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"disconnect failed: unknown result"];
}

- (DefaultReply *) disconnect: (Session *) session
{
  [self send_disconnect : session];
  return [self recv_disconnect];
}

- (void) send_post_score: (Session *) session category: (NSString *) category score: (Score *) score
{
  [outProtocol writeMessageBeginWithName: @"post_score" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"post_score_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (category != nil)  {
    [outProtocol writeFieldBeginWithName: @"category" type: TType_STRING fieldID: 2];
    [outProtocol writeString: category];
    [outProtocol writeFieldEnd];
  }
  if (score != nil)  {
    [outProtocol writeFieldBeginWithName: @"score" type: TType_STRUCT fieldID: 3];
    [score write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (PostScoreReply *) recv_post_score
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Post_score_result * result = [[[Post_score_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"post_score failed: unknown result"];
}

- (PostScoreReply *) post_score: (Session *) session category: (NSString *) category score: (Score *) score
{
  [self send_post_score : session category: category score: score];
  return [self recv_post_score];
}

- (void) send_get_scores: (Session *) session categoy: (NSString *) categoy player_id: (NSString *) player_id from_rank: (int32_t) from_rank count: (int64_t) count
{
  [outProtocol writeMessageBeginWithName: @"get_scores" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"get_scores_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (categoy != nil)  {
    [outProtocol writeFieldBeginWithName: @"categoy" type: TType_STRING fieldID: 2];
    [outProtocol writeString: categoy];
    [outProtocol writeFieldEnd];
  }
  if (player_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"player_id" type: TType_STRING fieldID: 3];
    [outProtocol writeString: player_id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"from_rank" type: TType_I32 fieldID: 4];
  [outProtocol writeI32: from_rank];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"count" type: TType_I64 fieldID: 5];
  [outProtocol writeI64: count];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (GetScoresReply *) recv_get_scores
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Get_scores_result * result = [[[Get_scores_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"get_scores failed: unknown result"];
}

- (GetScoresReply *) get_scores: (Session *) session categoy: (NSString *) categoy player_id: (NSString *) player_id from_rank: (int32_t) from_rank count: (int64_t) count
{
  [self send_get_scores : session categoy: categoy player_id: player_id from_rank: from_rank count: count];
  return [self recv_get_scores];
}

- (void) send_vote_score: (Session *) session voting_player_id: (NSString *) voting_player_id score_value: (int64_t) score_value score_date_epoch: (int64_t) score_date_epoch vote_up_down: (int32_t) vote_up_down comment: (NSString *) comment
{
  [outProtocol writeMessageBeginWithName: @"vote_score" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"vote_score_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (voting_player_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"voting_player_id" type: TType_STRING fieldID: 2];
    [outProtocol writeString: voting_player_id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"score_value" type: TType_I64 fieldID: 3];
  [outProtocol writeI64: score_value];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"score_date_epoch" type: TType_I64 fieldID: 4];
  [outProtocol writeI64: score_date_epoch];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"vote_up_down" type: TType_I32 fieldID: 5];
  [outProtocol writeI32: vote_up_down];
  [outProtocol writeFieldEnd];
  if (comment != nil)  {
    [outProtocol writeFieldBeginWithName: @"comment" type: TType_STRING fieldID: 6];
    [outProtocol writeString: comment];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_vote_score
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Vote_score_result * result = [[[Vote_score_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"vote_score failed: unknown result"];
}

- (DefaultReply *) vote_score: (Session *) session voting_player_id: (NSString *) voting_player_id score_value: (int64_t) score_value score_date_epoch: (int64_t) score_date_epoch vote_up_down: (int32_t) vote_up_down comment: (NSString *) comment
{
  [self send_vote_score : session voting_player_id: voting_player_id score_value: score_value score_date_epoch: score_date_epoch vote_up_down: vote_up_down comment: comment];
  return [self recv_vote_score];
}

@end

@implementation LeaderboardServiceProcessor

- (id) initWithLeaderboardService: (id <LeaderboardService>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain_stub];
  mMethodMap = [[NSMutableDictionary dictionary] retain_stub];
  {
    SEL s = @selector(process_connect_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"connect"];
  }
  {
    SEL s = @selector(process_disconnect_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"disconnect"];
  }
  {
    SEL s = @selector(process_post_score_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"post_score"];
  }
  {
    SEL s = @selector(process_get_scores_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"get_scores"];
  }
  {
    SEL s = @selector(process_vote_score_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"vote_score"];
  }
  return self;
}

- (id<LeaderboardService>) service
{
  return [[mService retain_stub] autorelease_stub];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_connect_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  connect_args * args = [[connect_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Connect_result * result = [[Connect_result alloc] init];
  [result setSuccess: [mService connect: [args protocol_version] player_id: [args player_id] player_password: [args player_password] user_data: [args user_data]]];
  [outProtocol writeMessageBeginWithName: @"connect"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_disconnect_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  disconnect_args * args = [[disconnect_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Disconnect_result * result = [[Disconnect_result alloc] init];
  [result setSuccess: [mService disconnect: [args session]]];
  [outProtocol writeMessageBeginWithName: @"disconnect"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_post_score_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  post_score_args * args = [[post_score_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Post_score_result * result = [[Post_score_result alloc] init];
  [result setSuccess: [mService post_score: [args session] category: [args category] score: [args score]]];
  [outProtocol writeMessageBeginWithName: @"post_score"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_get_scores_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  get_scores_args * args = [[get_scores_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Get_scores_result * result = [[Get_scores_result alloc] init];
  [result setSuccess: [mService get_scores: [args session] categoy: [args categoy] player_id: [args player_id] from_rank: [args from_rank] count: [args count]]];
  [outProtocol writeMessageBeginWithName: @"get_scores"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_vote_score_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  vote_score_args * args = [[vote_score_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Vote_score_result * result = [[Vote_score_result alloc] init];
  [result setSuccess: [mService vote_score: [args session] voting_player_id: [args voting_player_id] score_value: [args score_value] score_date_epoch: [args score_date_epoch] vote_up_down: [args vote_up_down] comment: [args comment]]];
  [outProtocol writeMessageBeginWithName: @"vote_score"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) dealloc
{
  [mService release_stub];
  [mMethodMap release_stub];
  [super dealloc_stub];
}

@end

