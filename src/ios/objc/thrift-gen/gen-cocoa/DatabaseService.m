/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"
#import "TObjective-C.h"
#import "TBase.h"


#import "DatabaseService.h"

@implementation ReplyStatus

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithError_code: (int) error_code error_message_format: (NSString *) error_message_format error_message_args: (NSMutableArray *) error_message_args
{
  self = [super init];
  __error_code = error_code;
  __error_code_isset = YES;
  __error_message_format = [error_message_format retain_stub];
  __error_message_format_isset = YES;
  __error_message_args = [error_message_args retain_stub];
  __error_message_args_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"error_code"])
  {
    __error_code = [decoder decodeIntForKey: @"error_code"];
    __error_code_isset = YES;
  }
  if ([decoder containsValueForKey: @"error_message_format"])
  {
    __error_message_format = [[decoder decodeObjectForKey: @"error_message_format"] retain_stub];
    __error_message_format_isset = YES;
  }
  if ([decoder containsValueForKey: @"error_message_args"])
  {
    __error_message_args = [[decoder decodeObjectForKey: @"error_message_args"] retain_stub];
    __error_message_args_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__error_code_isset)
  {
    [encoder encodeInt: __error_code forKey: @"error_code"];
  }
  if (__error_message_format_isset)
  {
    [encoder encodeObject: __error_message_format forKey: @"error_message_format"];
  }
  if (__error_message_args_isset)
  {
    [encoder encodeObject: __error_message_args forKey: @"error_message_args"];
  }
}

- (void) dealloc
{
  [__error_message_format release_stub];
  [__error_message_args release_stub];
  [super dealloc_stub];
}

- (int) error_code {
  return __error_code;
}

- (void) setError_code: (int) error_code {
  __error_code = error_code;
  __error_code_isset = YES;
}

- (BOOL) error_codeIsSet {
  return __error_code_isset;
}

- (void) unsetError_code {
  __error_code_isset = NO;
}

- (NSString *) error_message_format {
  return [[__error_message_format retain_stub] autorelease_stub];
}

- (void) setError_message_format: (NSString *) error_message_format {
  [error_message_format retain_stub];
  [__error_message_format release_stub];
  __error_message_format = error_message_format;
  __error_message_format_isset = YES;
}

- (BOOL) error_message_formatIsSet {
  return __error_message_format_isset;
}

- (void) unsetError_message_format {
  [__error_message_format release_stub];
  __error_message_format = nil;
  __error_message_format_isset = NO;
}

- (NSMutableArray *) error_message_args {
  return [[__error_message_args retain_stub] autorelease_stub];
}

- (void) setError_message_args: (NSMutableArray *) error_message_args {
  [error_message_args retain_stub];
  [__error_message_args release_stub];
  __error_message_args = error_message_args;
  __error_message_args_isset = YES;
}

- (BOOL) error_message_argsIsSet {
  return __error_message_args_isset;
}

- (void) unsetError_message_args {
  [__error_message_args release_stub];
  __error_message_args = nil;
  __error_message_args_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setError_code: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setError_message_format: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            NSString * _elem2 = [inProtocol readString];
            [fieldValue addObject: _elem2];
          }
          [inProtocol readListEnd];
          [self setError_message_args: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ReplyStatus"];
  if (__error_code_isset) {
    [outProtocol writeFieldBeginWithName: @"error_code" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __error_code];
    [outProtocol writeFieldEnd];
  }
  if (__error_message_format_isset) {
    if (__error_message_format != nil) {
      [outProtocol writeFieldBeginWithName: @"error_message_format" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __error_message_format];
      [outProtocol writeFieldEnd];
    }
  }
  if (__error_message_args_isset) {
    if (__error_message_args != nil) {
      [outProtocol writeFieldBeginWithName: @"error_message_args" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__error_message_args count]];
        int i4;
        for (i4 = 0; i4 < [__error_message_args count]; i4++)
        {
          [outProtocol writeString: [__error_message_args objectAtIndex: i4]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ReplyStatus("];
  [ms appendString: @"error_code:"];
  [ms appendFormat: @"%i", __error_code];
  [ms appendString: @",error_message_format:"];
  [ms appendFormat: @"\"%@\"", __error_message_format];
  [ms appendString: @",error_message_args:"];
  [ms appendFormat: @"%@", __error_message_args];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation DefaultReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"DefaultReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"DefaultReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation TableGetReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status key: (NSData *) key value: (NSData *) value key_order: (KeyOrder) key_order
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  __value = [value retain_stub];
  __value_isset = YES;
  __key_order = key_order;
  __key_order_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  if ([decoder containsValueForKey: @"value"])
  {
    __value = [[decoder decodeObjectForKey: @"value"] retain_stub];
    __value_isset = YES;
  }
  if ([decoder containsValueForKey: @"key_order"])
  {
    __key_order = [decoder decodeInt64ForKey: @"key_order"];
    __key_order_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
  if (__value_isset)
  {
    [encoder encodeObject: __value forKey: @"value"];
  }
  if (__key_order_isset)
  {
    [encoder encodeInt64: __key_order forKey: @"key_order"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [__key release_stub];
  [__value release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (NSData *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSData *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (NSData *) value {
  return [[__value retain_stub] autorelease_stub];
}

- (void) setValue: (NSData *) value {
  [value retain_stub];
  [__value release_stub];
  __value = value;
  __value_isset = YES;
}

- (BOOL) valueIsSet {
  return __value_isset;
}

- (void) unsetValue {
  [__value release_stub];
  __value = nil;
  __value_isset = NO;
}

- (int64_t) key_order {
  return __key_order;
}

- (void) setKey_order: (int64_t) key_order {
  __key_order = key_order;
  __key_order_isset = YES;
}

- (BOOL) key_orderIsSet {
  return __key_order_isset;
}

- (void) unsetKey_order {
  __key_order_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setValue: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setKey_order: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"TableGetReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __key];
      [outProtocol writeFieldEnd];
    }
  }
  if (__value_isset) {
    if (__value != nil) {
      [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __value];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_order_isset) {
    [outProtocol writeFieldBeginWithName: @"key_order" type: TType_I64 fieldID: 4];
    [outProtocol writeI64: __key_order];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"TableGetReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @",value:"];
  [ms appendFormat: @"\"%@\"", __value];
  [ms appendString: @",key_order:"];
  [ms appendFormat: @"%qi", __key_order];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation TableStatReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status key_count: (KeyOrder) key_count
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  __key_count = key_count;
  __key_count_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"key_count"])
  {
    __key_count = [decoder decodeInt64ForKey: @"key_count"];
    __key_count_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
  if (__key_count_isset)
  {
    [encoder encodeInt64: __key_count forKey: @"key_count"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (int64_t) key_count {
  return __key_count;
}

- (void) setKey_count: (int64_t) key_count {
  __key_count = key_count;
  __key_count_isset = YES;
}

- (BOOL) key_countIsSet {
  return __key_count_isset;
}

- (void) unsetKey_count {
  __key_count_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setKey_count: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"TableStatReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_count_isset) {
    [outProtocol writeFieldBeginWithName: @"key_count" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __key_count];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"TableStatReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @",key_count:"];
  [ms appendFormat: @"%qi", __key_count];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation CursorOpenReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status cursor_handle: (CursorHandle) cursor_handle
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  __cursor_handle = cursor_handle;
  __cursor_handle_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"cursor_handle"])
  {
    __cursor_handle = [decoder decodeInt64ForKey: @"cursor_handle"];
    __cursor_handle_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
  if (__cursor_handle_isset)
  {
    [encoder encodeInt64: __cursor_handle forKey: @"cursor_handle"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (int64_t) cursor_handle {
  return __cursor_handle;
}

- (void) setCursor_handle: (int64_t) cursor_handle {
  __cursor_handle = cursor_handle;
  __cursor_handle_isset = YES;
}

- (BOOL) cursor_handleIsSet {
  return __cursor_handle_isset;
}

- (void) unsetCursor_handle {
  __cursor_handle_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCursor_handle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CursorOpenReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__cursor_handle_isset) {
    [outProtocol writeFieldBeginWithName: @"cursor_handle" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __cursor_handle];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CursorOpenReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @",cursor_handle:"];
  [ms appendFormat: @"%qi", __cursor_handle];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation CursorFetchReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status key: (NSData *) key key_order: (KeyOrder) key_order value: (NSData *) value
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  __key_order = key_order;
  __key_order_isset = YES;
  __value = [value retain_stub];
  __value_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  if ([decoder containsValueForKey: @"key_order"])
  {
    __key_order = [decoder decodeInt64ForKey: @"key_order"];
    __key_order_isset = YES;
  }
  if ([decoder containsValueForKey: @"value"])
  {
    __value = [[decoder decodeObjectForKey: @"value"] retain_stub];
    __value_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
  if (__key_order_isset)
  {
    [encoder encodeInt64: __key_order forKey: @"key_order"];
  }
  if (__value_isset)
  {
    [encoder encodeObject: __value forKey: @"value"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [__key release_stub];
  [__value release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (NSData *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSData *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (int64_t) key_order {
  return __key_order;
}

- (void) setKey_order: (int64_t) key_order {
  __key_order = key_order;
  __key_order_isset = YES;
}

- (BOOL) key_orderIsSet {
  return __key_order_isset;
}

- (void) unsetKey_order {
  __key_order_isset = NO;
}

- (NSData *) value {
  return [[__value retain_stub] autorelease_stub];
}

- (void) setValue: (NSData *) value {
  [value retain_stub];
  [__value release_stub];
  __value = value;
  __value_isset = YES;
}

- (BOOL) valueIsSet {
  return __value_isset;
}

- (void) unsetValue {
  [__value release_stub];
  __value = nil;
  __value_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setKey_order: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setValue: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CursorFetchReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __key];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_order_isset) {
    [outProtocol writeFieldBeginWithName: @"key_order" type: TType_I64 fieldID: 3];
    [outProtocol writeI64: __key_order];
    [outProtocol writeFieldEnd];
  }
  if (__value_isset) {
    if (__value != nil) {
      [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
      [outProtocol writeBinary: __value];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CursorFetchReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @",key_order:"];
  [ms appendFormat: @"%qi", __key_order];
  [ms appendString: @",value:"];
  [ms appendFormat: @"\"%@\"", __value];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation Session

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession_handle: (int32_t) session_handle
{
  self = [super init];
  __session_handle = session_handle;
  __session_handle_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session_handle"])
  {
    __session_handle = [decoder decodeInt32ForKey: @"session_handle"];
    __session_handle_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_handle_isset)
  {
    [encoder encodeInt32: __session_handle forKey: @"session_handle"];
  }
}

- (void) dealloc
{
  [super dealloc_stub];
}

- (int32_t) session_handle {
  return __session_handle;
}

- (void) setSession_handle: (int32_t) session_handle {
  __session_handle = session_handle;
  __session_handle_isset = YES;
}

- (BOOL) session_handleIsSet {
  return __session_handle_isset;
}

- (void) unsetSession_handle {
  __session_handle_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSession_handle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Session"];
  if (__session_handle_isset) {
    [outProtocol writeFieldBeginWithName: @"session_handle" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __session_handle];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Session("];
  [ms appendString: @"session_handle:"];
  [ms appendFormat: @"%i", __session_handle];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation ConnectReply

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (ReplyStatus *) status session_handle: (int32_t) session_handle
{
  self = [super init];
  __status = [status retain_stub];
  __status_isset = YES;
  __session_handle = session_handle;
  __session_handle_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [[decoder decodeObjectForKey: @"status"] retain_stub];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"session_handle"])
  {
    __session_handle = [decoder decodeInt32ForKey: @"session_handle"];
    __session_handle_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeObject: __status forKey: @"status"];
  }
  if (__session_handle_isset)
  {
    [encoder encodeInt32: __session_handle forKey: @"session_handle"];
  }
}

- (void) dealloc
{
  [__status release_stub];
  [super dealloc_stub];
}

- (ReplyStatus *) status {
  return [[__status retain_stub] autorelease_stub];
}

- (void) setStatus: (ReplyStatus *) status {
  [status retain_stub];
  [__status release_stub];
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  [__status release_stub];
  __status = nil;
  __status_isset = NO;
}

- (int32_t) session_handle {
  return __session_handle;
}

- (void) setSession_handle: (int32_t) session_handle {
  __session_handle = session_handle;
  __session_handle_isset = YES;
}

- (BOOL) session_handleIsSet {
  return __session_handle_isset;
}

- (void) unsetSession_handle {
  __session_handle_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          ReplyStatus *fieldValue = [[ReplyStatus alloc] init];
          [fieldValue read: inProtocol];
          [self setStatus: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSession_handle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ConnectReply"];
  if (__status_isset) {
    if (__status != nil) {
      [outProtocol writeFieldBeginWithName: @"status" type: TType_STRUCT fieldID: 1];
      [__status write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__session_handle_isset) {
    [outProtocol writeFieldBeginWithName: @"session_handle" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __session_handle];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ConnectReply("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%@", __status];
  [ms appendString: @",session_handle:"];
  [ms appendFormat: @"%i", __session_handle];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end


@implementation DatabaseServiceConstants
+ (void) initialize {
}
@end

@interface connect_args : NSObject <TBase, NSCoding> {
}

- (id) init;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

@end

@implementation connect_args

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"connect_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"connect_args("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Connect_result : NSObject <TBase, NSCoding> {
  ConnectReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) ConnectReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (ConnectReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (ConnectReply *) success;
- (void) setSuccess: (ConnectReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Connect_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (ConnectReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (ConnectReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (ConnectReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          ConnectReply *fieldValue = [[ConnectReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Connect_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Connect_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface disconnect_args : NSObject <TBase, NSCoding> {
  Session * __session;

  BOOL __session_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
#endif

- (id) init;
- (id) initWithSession: (Session *) session;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

@end

@implementation disconnect_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"disconnect_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"disconnect_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Disconnect_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Disconnect_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Disconnect_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Disconnect_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface database_create_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __db_name;

  BOOL __session_isset;
  BOOL __db_name_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=db_name, setter=setDb_name:) NSString * db_name;
#endif

- (id) init;
- (id) initWithSession: (Session *) session db_name: (NSString *) db_name;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) db_name;
- (void) setDb_name: (NSString *) db_name;
#endif
- (BOOL) db_nameIsSet;

@end

@implementation database_create_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session db_name: (NSString *) db_name
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __db_name = [db_name retain_stub];
  __db_name_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"db_name"])
  {
    __db_name = [[decoder decodeObjectForKey: @"db_name"] retain_stub];
    __db_name_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__db_name_isset)
  {
    [encoder encodeObject: __db_name forKey: @"db_name"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__db_name release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) db_name {
  return [[__db_name retain_stub] autorelease_stub];
}

- (void) setDb_name: (NSString *) db_name {
  [db_name retain_stub];
  [__db_name release_stub];
  __db_name = db_name;
  __db_name_isset = YES;
}

- (BOOL) db_nameIsSet {
  return __db_name_isset;
}

- (void) unsetDb_name {
  [__db_name release_stub];
  __db_name = nil;
  __db_name_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setDb_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"database_create_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__db_name_isset) {
    if (__db_name != nil) {
      [outProtocol writeFieldBeginWithName: @"db_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __db_name];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"database_create_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",db_name:"];
  [ms appendFormat: @"\"%@\"", __db_name];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Database_create_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Database_create_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Database_create_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Database_create_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface database_drop_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __db_name;

  BOOL __session_isset;
  BOOL __db_name_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=db_name, setter=setDb_name:) NSString * db_name;
#endif

- (id) init;
- (id) initWithSession: (Session *) session db_name: (NSString *) db_name;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) db_name;
- (void) setDb_name: (NSString *) db_name;
#endif
- (BOOL) db_nameIsSet;

@end

@implementation database_drop_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session db_name: (NSString *) db_name
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __db_name = [db_name retain_stub];
  __db_name_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"db_name"])
  {
    __db_name = [[decoder decodeObjectForKey: @"db_name"] retain_stub];
    __db_name_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__db_name_isset)
  {
    [encoder encodeObject: __db_name forKey: @"db_name"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__db_name release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) db_name {
  return [[__db_name retain_stub] autorelease_stub];
}

- (void) setDb_name: (NSString *) db_name {
  [db_name retain_stub];
  [__db_name release_stub];
  __db_name = db_name;
  __db_name_isset = YES;
}

- (BOOL) db_nameIsSet {
  return __db_name_isset;
}

- (void) unsetDb_name {
  [__db_name release_stub];
  __db_name = nil;
  __db_name_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setDb_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"database_drop_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__db_name_isset) {
    if (__db_name != nil) {
      [outProtocol writeFieldBeginWithName: @"db_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __db_name];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"database_drop_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",db_name:"];
  [ms appendFormat: @"\"%@\"", __db_name];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Database_drop_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Database_drop_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Database_drop_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Database_drop_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface database_use_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __db_name;

  BOOL __session_isset;
  BOOL __db_name_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=db_name, setter=setDb_name:) NSString * db_name;
#endif

- (id) init;
- (id) initWithSession: (Session *) session db_name: (NSString *) db_name;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) db_name;
- (void) setDb_name: (NSString *) db_name;
#endif
- (BOOL) db_nameIsSet;

@end

@implementation database_use_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session db_name: (NSString *) db_name
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __db_name = [db_name retain_stub];
  __db_name_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"db_name"])
  {
    __db_name = [[decoder decodeObjectForKey: @"db_name"] retain_stub];
    __db_name_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__db_name_isset)
  {
    [encoder encodeObject: __db_name forKey: @"db_name"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__db_name release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) db_name {
  return [[__db_name retain_stub] autorelease_stub];
}

- (void) setDb_name: (NSString *) db_name {
  [db_name retain_stub];
  [__db_name release_stub];
  __db_name = db_name;
  __db_name_isset = YES;
}

- (BOOL) db_nameIsSet {
  return __db_name_isset;
}

- (void) unsetDb_name {
  [__db_name release_stub];
  __db_name = nil;
  __db_name_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setDb_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"database_use_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__db_name_isset) {
    if (__db_name != nil) {
      [outProtocol writeFieldBeginWithName: @"db_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __db_name];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"database_use_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",db_name:"];
  [ms appendFormat: @"\"%@\"", __db_name];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Database_use_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Database_use_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Database_use_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Database_use_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface table_create_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __table_name;

  BOOL __session_isset;
  BOOL __table_name_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=table_name, setter=setTable_name:) NSString * table_name;
#endif

- (id) init;
- (id) initWithSession: (Session *) session table_name: (NSString *) table_name;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) table_name;
- (void) setTable_name: (NSString *) table_name;
#endif
- (BOOL) table_nameIsSet;

@end

@implementation table_create_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session table_name: (NSString *) table_name
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __table_name = [table_name retain_stub];
  __table_name_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"table_name"])
  {
    __table_name = [[decoder decodeObjectForKey: @"table_name"] retain_stub];
    __table_name_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__table_name_isset)
  {
    [encoder encodeObject: __table_name forKey: @"table_name"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__table_name release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) table_name {
  return [[__table_name retain_stub] autorelease_stub];
}

- (void) setTable_name: (NSString *) table_name {
  [table_name retain_stub];
  [__table_name release_stub];
  __table_name = table_name;
  __table_name_isset = YES;
}

- (BOOL) table_nameIsSet {
  return __table_name_isset;
}

- (void) unsetTable_name {
  [__table_name release_stub];
  __table_name = nil;
  __table_name_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTable_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"table_create_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__table_name_isset) {
    if (__table_name != nil) {
      [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __table_name];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"table_create_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",table_name:"];
  [ms appendFormat: @"\"%@\"", __table_name];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Table_create_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Table_create_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Table_create_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Table_create_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface table_drop_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __table_name;

  BOOL __session_isset;
  BOOL __table_name_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=table_name, setter=setTable_name:) NSString * table_name;
#endif

- (id) init;
- (id) initWithSession: (Session *) session table_name: (NSString *) table_name;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) table_name;
- (void) setTable_name: (NSString *) table_name;
#endif
- (BOOL) table_nameIsSet;

@end

@implementation table_drop_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session table_name: (NSString *) table_name
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __table_name = [table_name retain_stub];
  __table_name_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"table_name"])
  {
    __table_name = [[decoder decodeObjectForKey: @"table_name"] retain_stub];
    __table_name_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__table_name_isset)
  {
    [encoder encodeObject: __table_name forKey: @"table_name"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__table_name release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) table_name {
  return [[__table_name retain_stub] autorelease_stub];
}

- (void) setTable_name: (NSString *) table_name {
  [table_name retain_stub];
  [__table_name release_stub];
  __table_name = table_name;
  __table_name_isset = YES;
}

- (BOOL) table_nameIsSet {
  return __table_name_isset;
}

- (void) unsetTable_name {
  [__table_name release_stub];
  __table_name = nil;
  __table_name_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTable_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"table_drop_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__table_name_isset) {
    if (__table_name != nil) {
      [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __table_name];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"table_drop_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",table_name:"];
  [ms appendFormat: @"\"%@\"", __table_name];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Table_drop_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Table_drop_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Table_drop_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Table_drop_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface table_stat_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __table_name;

  BOOL __session_isset;
  BOOL __table_name_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=table_name, setter=setTable_name:) NSString * table_name;
#endif

- (id) init;
- (id) initWithSession: (Session *) session table_name: (NSString *) table_name;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) table_name;
- (void) setTable_name: (NSString *) table_name;
#endif
- (BOOL) table_nameIsSet;

@end

@implementation table_stat_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session table_name: (NSString *) table_name
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __table_name = [table_name retain_stub];
  __table_name_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"table_name"])
  {
    __table_name = [[decoder decodeObjectForKey: @"table_name"] retain_stub];
    __table_name_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__table_name_isset)
  {
    [encoder encodeObject: __table_name forKey: @"table_name"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__table_name release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) table_name {
  return [[__table_name retain_stub] autorelease_stub];
}

- (void) setTable_name: (NSString *) table_name {
  [table_name retain_stub];
  [__table_name release_stub];
  __table_name = table_name;
  __table_name_isset = YES;
}

- (BOOL) table_nameIsSet {
  return __table_name_isset;
}

- (void) unsetTable_name {
  [__table_name release_stub];
  __table_name = nil;
  __table_name_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTable_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"table_stat_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__table_name_isset) {
    if (__table_name != nil) {
      [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __table_name];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"table_stat_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",table_name:"];
  [ms appendFormat: @"\"%@\"", __table_name];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Table_stat_result : NSObject <TBase, NSCoding> {
  TableStatReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) TableStatReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (TableStatReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (TableStatReply *) success;
- (void) setSuccess: (TableStatReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Table_stat_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (TableStatReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (TableStatReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (TableStatReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          TableStatReply *fieldValue = [[TableStatReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Table_stat_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Table_stat_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface table_put_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __table_name;
  NSData * __key;
  NSData * __value;

  BOOL __session_isset;
  BOOL __table_name_isset;
  BOOL __key_isset;
  BOOL __value_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=table_name, setter=setTable_name:) NSString * table_name;
@property (nonatomic, retain, getter=key, setter=setKey:) NSData * key;
@property (nonatomic, retain, getter=value, setter=setValue:) NSData * value;
#endif

- (id) init;
- (id) initWithSession: (Session *) session table_name: (NSString *) table_name key: (NSData *) key value: (NSData *) value;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) table_name;
- (void) setTable_name: (NSString *) table_name;
#endif
- (BOOL) table_nameIsSet;

#if !__has_feature(objc_arc)
- (NSData *) key;
- (void) setKey: (NSData *) key;
#endif
- (BOOL) keyIsSet;

#if !__has_feature(objc_arc)
- (NSData *) value;
- (void) setValue: (NSData *) value;
#endif
- (BOOL) valueIsSet;

@end

@implementation table_put_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session table_name: (NSString *) table_name key: (NSData *) key value: (NSData *) value
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __table_name = [table_name retain_stub];
  __table_name_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  __value = [value retain_stub];
  __value_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"table_name"])
  {
    __table_name = [[decoder decodeObjectForKey: @"table_name"] retain_stub];
    __table_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  if ([decoder containsValueForKey: @"value"])
  {
    __value = [[decoder decodeObjectForKey: @"value"] retain_stub];
    __value_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__table_name_isset)
  {
    [encoder encodeObject: __table_name forKey: @"table_name"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
  if (__value_isset)
  {
    [encoder encodeObject: __value forKey: @"value"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__table_name release_stub];
  [__key release_stub];
  [__value release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) table_name {
  return [[__table_name retain_stub] autorelease_stub];
}

- (void) setTable_name: (NSString *) table_name {
  [table_name retain_stub];
  [__table_name release_stub];
  __table_name = table_name;
  __table_name_isset = YES;
}

- (BOOL) table_nameIsSet {
  return __table_name_isset;
}

- (void) unsetTable_name {
  [__table_name release_stub];
  __table_name = nil;
  __table_name_isset = NO;
}

- (NSData *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSData *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (NSData *) value {
  return [[__value retain_stub] autorelease_stub];
}

- (void) setValue: (NSData *) value {
  [value retain_stub];
  [__value release_stub];
  __value = value;
  __value_isset = YES;
}

- (BOOL) valueIsSet {
  return __value_isset;
}

- (void) unsetValue {
  [__value release_stub];
  __value = nil;
  __value_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTable_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setValue: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"table_put_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__table_name_isset) {
    if (__table_name != nil) {
      [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __table_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __key];
      [outProtocol writeFieldEnd];
    }
  }
  if (__value_isset) {
    if (__value != nil) {
      [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
      [outProtocol writeBinary: __value];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"table_put_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",table_name:"];
  [ms appendFormat: @"\"%@\"", __table_name];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @",value:"];
  [ms appendFormat: @"\"%@\"", __value];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Table_put_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Table_put_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Table_put_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Table_put_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface table_get_by_key_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __table_name;
  NSData * __key;

  BOOL __session_isset;
  BOOL __table_name_isset;
  BOOL __key_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=table_name, setter=setTable_name:) NSString * table_name;
@property (nonatomic, retain, getter=key, setter=setKey:) NSData * key;
#endif

- (id) init;
- (id) initWithSession: (Session *) session table_name: (NSString *) table_name key: (NSData *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) table_name;
- (void) setTable_name: (NSString *) table_name;
#endif
- (BOOL) table_nameIsSet;

#if !__has_feature(objc_arc)
- (NSData *) key;
- (void) setKey: (NSData *) key;
#endif
- (BOOL) keyIsSet;

@end

@implementation table_get_by_key_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session table_name: (NSString *) table_name key: (NSData *) key
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __table_name = [table_name retain_stub];
  __table_name_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"table_name"])
  {
    __table_name = [[decoder decodeObjectForKey: @"table_name"] retain_stub];
    __table_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__table_name_isset)
  {
    [encoder encodeObject: __table_name forKey: @"table_name"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__table_name release_stub];
  [__key release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) table_name {
  return [[__table_name retain_stub] autorelease_stub];
}

- (void) setTable_name: (NSString *) table_name {
  [table_name retain_stub];
  [__table_name release_stub];
  __table_name = table_name;
  __table_name_isset = YES;
}

- (BOOL) table_nameIsSet {
  return __table_name_isset;
}

- (void) unsetTable_name {
  [__table_name release_stub];
  __table_name = nil;
  __table_name_isset = NO;
}

- (NSData *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSData *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTable_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"table_get_by_key_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__table_name_isset) {
    if (__table_name != nil) {
      [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __table_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"table_get_by_key_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",table_name:"];
  [ms appendFormat: @"\"%@\"", __table_name];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Table_get_by_key_result : NSObject <TBase, NSCoding> {
  TableGetReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) TableGetReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (TableGetReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (TableGetReply *) success;
- (void) setSuccess: (TableGetReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Table_get_by_key_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (TableGetReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (TableGetReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (TableGetReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          TableGetReply *fieldValue = [[TableGetReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Table_get_by_key_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Table_get_by_key_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface table_get_by_order_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __table_name;
  KeyOrder __keyOrder;

  BOOL __session_isset;
  BOOL __table_name_isset;
  BOOL __keyOrder_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=table_name, setter=setTable_name:) NSString * table_name;
@property (nonatomic, getter=keyOrder, setter=setKeyOrder:) KeyOrder keyOrder;
#endif

- (id) init;
- (id) initWithSession: (Session *) session table_name: (NSString *) table_name keyOrder: (KeyOrder) keyOrder;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) table_name;
- (void) setTable_name: (NSString *) table_name;
#endif
- (BOOL) table_nameIsSet;

#if !__has_feature(objc_arc)
- (KeyOrder) keyOrder;
- (void) setKeyOrder: (KeyOrder) keyOrder;
#endif
- (BOOL) keyOrderIsSet;

@end

@implementation table_get_by_order_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session table_name: (NSString *) table_name keyOrder: (KeyOrder) keyOrder
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __table_name = [table_name retain_stub];
  __table_name_isset = YES;
  __keyOrder = keyOrder;
  __keyOrder_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"table_name"])
  {
    __table_name = [[decoder decodeObjectForKey: @"table_name"] retain_stub];
    __table_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"keyOrder"])
  {
    __keyOrder = [decoder decodeInt64ForKey: @"keyOrder"];
    __keyOrder_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__table_name_isset)
  {
    [encoder encodeObject: __table_name forKey: @"table_name"];
  }
  if (__keyOrder_isset)
  {
    [encoder encodeInt64: __keyOrder forKey: @"keyOrder"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__table_name release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) table_name {
  return [[__table_name retain_stub] autorelease_stub];
}

- (void) setTable_name: (NSString *) table_name {
  [table_name retain_stub];
  [__table_name release_stub];
  __table_name = table_name;
  __table_name_isset = YES;
}

- (BOOL) table_nameIsSet {
  return __table_name_isset;
}

- (void) unsetTable_name {
  [__table_name release_stub];
  __table_name = nil;
  __table_name_isset = NO;
}

- (int64_t) keyOrder {
  return __keyOrder;
}

- (void) setKeyOrder: (int64_t) keyOrder {
  __keyOrder = keyOrder;
  __keyOrder_isset = YES;
}

- (BOOL) keyOrderIsSet {
  return __keyOrder_isset;
}

- (void) unsetKeyOrder {
  __keyOrder_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTable_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setKeyOrder: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"table_get_by_order_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__table_name_isset) {
    if (__table_name != nil) {
      [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __table_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__keyOrder_isset) {
    [outProtocol writeFieldBeginWithName: @"keyOrder" type: TType_I64 fieldID: 3];
    [outProtocol writeI64: __keyOrder];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"table_get_by_order_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",table_name:"];
  [ms appendFormat: @"\"%@\"", __table_name];
  [ms appendString: @",keyOrder:"];
  [ms appendFormat: @"%qi", __keyOrder];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Table_get_by_order_result : NSObject <TBase, NSCoding> {
  TableGetReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) TableGetReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (TableGetReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (TableGetReply *) success;
- (void) setSuccess: (TableGetReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Table_get_by_order_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (TableGetReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (TableGetReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (TableGetReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          TableGetReply *fieldValue = [[TableGetReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Table_get_by_order_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Table_get_by_order_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface table_del_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __table_name;
  NSData * __key;

  BOOL __session_isset;
  BOOL __table_name_isset;
  BOOL __key_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=table_name, setter=setTable_name:) NSString * table_name;
@property (nonatomic, retain, getter=key, setter=setKey:) NSData * key;
#endif

- (id) init;
- (id) initWithSession: (Session *) session table_name: (NSString *) table_name key: (NSData *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) table_name;
- (void) setTable_name: (NSString *) table_name;
#endif
- (BOOL) table_nameIsSet;

#if !__has_feature(objc_arc)
- (NSData *) key;
- (void) setKey: (NSData *) key;
#endif
- (BOOL) keyIsSet;

@end

@implementation table_del_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session table_name: (NSString *) table_name key: (NSData *) key
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __table_name = [table_name retain_stub];
  __table_name_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"table_name"])
  {
    __table_name = [[decoder decodeObjectForKey: @"table_name"] retain_stub];
    __table_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__table_name_isset)
  {
    [encoder encodeObject: __table_name forKey: @"table_name"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__table_name release_stub];
  [__key release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) table_name {
  return [[__table_name retain_stub] autorelease_stub];
}

- (void) setTable_name: (NSString *) table_name {
  [table_name retain_stub];
  [__table_name release_stub];
  __table_name = table_name;
  __table_name_isset = YES;
}

- (BOOL) table_nameIsSet {
  return __table_name_isset;
}

- (void) unsetTable_name {
  [__table_name release_stub];
  __table_name = nil;
  __table_name_isset = NO;
}

- (NSData *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSData *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTable_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"table_del_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__table_name_isset) {
    if (__table_name != nil) {
      [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __table_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"table_del_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",table_name:"];
  [ms appendFormat: @"\"%@\"", __table_name];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Table_del_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Table_del_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Table_del_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Table_del_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface transaction_begin_args : NSObject <TBase, NSCoding> {
  Session * __session;

  BOOL __session_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
#endif

- (id) init;
- (id) initWithSession: (Session *) session;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

@end

@implementation transaction_begin_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"transaction_begin_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"transaction_begin_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Transaction_begin_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Transaction_begin_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Transaction_begin_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Transaction_begin_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface transaction_abort_args : NSObject <TBase, NSCoding> {
  Session * __session;

  BOOL __session_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
#endif

- (id) init;
- (id) initWithSession: (Session *) session;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

@end

@implementation transaction_abort_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"transaction_abort_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"transaction_abort_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Transaction_abort_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Transaction_abort_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Transaction_abort_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Transaction_abort_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface transaction_commit_args : NSObject <TBase, NSCoding> {
  Session * __session;

  BOOL __session_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
#endif

- (id) init;
- (id) initWithSession: (Session *) session;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

@end

@implementation transaction_commit_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"transaction_commit_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"transaction_commit_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Transaction_commit_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Transaction_commit_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Transaction_commit_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Transaction_commit_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface cursor_open_by_key_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __table_name;
  int __dir;
  NSData * __key;

  BOOL __session_isset;
  BOOL __table_name_isset;
  BOOL __dir_isset;
  BOOL __key_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=table_name, setter=setTable_name:) NSString * table_name;
@property (nonatomic, getter=dir, setter=setDir:) int dir;
@property (nonatomic, retain, getter=key, setter=setKey:) NSData * key;
#endif

- (id) init;
- (id) initWithSession: (Session *) session table_name: (NSString *) table_name dir: (int) dir key: (NSData *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) table_name;
- (void) setTable_name: (NSString *) table_name;
#endif
- (BOOL) table_nameIsSet;

#if !__has_feature(objc_arc)
- (int) dir;
- (void) setDir: (int) dir;
#endif
- (BOOL) dirIsSet;

#if !__has_feature(objc_arc)
- (NSData *) key;
- (void) setKey: (NSData *) key;
#endif
- (BOOL) keyIsSet;

@end

@implementation cursor_open_by_key_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session table_name: (NSString *) table_name dir: (int) dir key: (NSData *) key
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __table_name = [table_name retain_stub];
  __table_name_isset = YES;
  __dir = dir;
  __dir_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"table_name"])
  {
    __table_name = [[decoder decodeObjectForKey: @"table_name"] retain_stub];
    __table_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"dir"])
  {
    __dir = [decoder decodeIntForKey: @"dir"];
    __dir_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__table_name_isset)
  {
    [encoder encodeObject: __table_name forKey: @"table_name"];
  }
  if (__dir_isset)
  {
    [encoder encodeInt: __dir forKey: @"dir"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__table_name release_stub];
  [__key release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) table_name {
  return [[__table_name retain_stub] autorelease_stub];
}

- (void) setTable_name: (NSString *) table_name {
  [table_name retain_stub];
  [__table_name release_stub];
  __table_name = table_name;
  __table_name_isset = YES;
}

- (BOOL) table_nameIsSet {
  return __table_name_isset;
}

- (void) unsetTable_name {
  [__table_name release_stub];
  __table_name = nil;
  __table_name_isset = NO;
}

- (int) dir {
  return __dir;
}

- (void) setDir: (int) dir {
  __dir = dir;
  __dir_isset = YES;
}

- (BOOL) dirIsSet {
  return __dir_isset;
}

- (void) unsetDir {
  __dir_isset = NO;
}

- (NSData *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSData *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTable_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setDir: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"cursor_open_by_key_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__table_name_isset) {
    if (__table_name != nil) {
      [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __table_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__dir_isset) {
    [outProtocol writeFieldBeginWithName: @"dir" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __dir];
    [outProtocol writeFieldEnd];
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 4];
      [outProtocol writeBinary: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"cursor_open_by_key_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",table_name:"];
  [ms appendFormat: @"\"%@\"", __table_name];
  [ms appendString: @",dir:"];
  [ms appendFormat: @"%i", __dir];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Cursor_open_by_key_result : NSObject <TBase, NSCoding> {
  CursorOpenReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) CursorOpenReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (CursorOpenReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (CursorOpenReply *) success;
- (void) setSuccess: (CursorOpenReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Cursor_open_by_key_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (CursorOpenReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (CursorOpenReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (CursorOpenReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          CursorOpenReply *fieldValue = [[CursorOpenReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Cursor_open_by_key_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Cursor_open_by_key_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface cursor_open_by_order_args : NSObject <TBase, NSCoding> {
  Session * __session;
  NSString * __table_name;
  int __dir;
  KeyOrder __keyOrder;

  BOOL __session_isset;
  BOOL __table_name_isset;
  BOOL __dir_isset;
  BOOL __keyOrder_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, retain, getter=table_name, setter=setTable_name:) NSString * table_name;
@property (nonatomic, getter=dir, setter=setDir:) int dir;
@property (nonatomic, getter=keyOrder, setter=setKeyOrder:) KeyOrder keyOrder;
#endif

- (id) init;
- (id) initWithSession: (Session *) session table_name: (NSString *) table_name dir: (int) dir keyOrder: (KeyOrder) keyOrder;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (NSString *) table_name;
- (void) setTable_name: (NSString *) table_name;
#endif
- (BOOL) table_nameIsSet;

#if !__has_feature(objc_arc)
- (int) dir;
- (void) setDir: (int) dir;
#endif
- (BOOL) dirIsSet;

#if !__has_feature(objc_arc)
- (KeyOrder) keyOrder;
- (void) setKeyOrder: (KeyOrder) keyOrder;
#endif
- (BOOL) keyOrderIsSet;

@end

@implementation cursor_open_by_order_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session table_name: (NSString *) table_name dir: (int) dir keyOrder: (KeyOrder) keyOrder
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __table_name = [table_name retain_stub];
  __table_name_isset = YES;
  __dir = dir;
  __dir_isset = YES;
  __keyOrder = keyOrder;
  __keyOrder_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"table_name"])
  {
    __table_name = [[decoder decodeObjectForKey: @"table_name"] retain_stub];
    __table_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"dir"])
  {
    __dir = [decoder decodeIntForKey: @"dir"];
    __dir_isset = YES;
  }
  if ([decoder containsValueForKey: @"keyOrder"])
  {
    __keyOrder = [decoder decodeInt64ForKey: @"keyOrder"];
    __keyOrder_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__table_name_isset)
  {
    [encoder encodeObject: __table_name forKey: @"table_name"];
  }
  if (__dir_isset)
  {
    [encoder encodeInt: __dir forKey: @"dir"];
  }
  if (__keyOrder_isset)
  {
    [encoder encodeInt64: __keyOrder forKey: @"keyOrder"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [__table_name release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (NSString *) table_name {
  return [[__table_name retain_stub] autorelease_stub];
}

- (void) setTable_name: (NSString *) table_name {
  [table_name retain_stub];
  [__table_name release_stub];
  __table_name = table_name;
  __table_name_isset = YES;
}

- (BOOL) table_nameIsSet {
  return __table_name_isset;
}

- (void) unsetTable_name {
  [__table_name release_stub];
  __table_name = nil;
  __table_name_isset = NO;
}

- (int) dir {
  return __dir;
}

- (void) setDir: (int) dir {
  __dir = dir;
  __dir_isset = YES;
}

- (BOOL) dirIsSet {
  return __dir_isset;
}

- (void) unsetDir {
  __dir_isset = NO;
}

- (int64_t) keyOrder {
  return __keyOrder;
}

- (void) setKeyOrder: (int64_t) keyOrder {
  __keyOrder = keyOrder;
  __keyOrder_isset = YES;
}

- (BOOL) keyOrderIsSet {
  return __keyOrder_isset;
}

- (void) unsetKeyOrder {
  __keyOrder_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTable_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setDir: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setKeyOrder: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"cursor_open_by_order_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__table_name_isset) {
    if (__table_name != nil) {
      [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __table_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__dir_isset) {
    [outProtocol writeFieldBeginWithName: @"dir" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __dir];
    [outProtocol writeFieldEnd];
  }
  if (__keyOrder_isset) {
    [outProtocol writeFieldBeginWithName: @"keyOrder" type: TType_I64 fieldID: 4];
    [outProtocol writeI64: __keyOrder];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"cursor_open_by_order_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",table_name:"];
  [ms appendFormat: @"\"%@\"", __table_name];
  [ms appendString: @",dir:"];
  [ms appendFormat: @"%i", __dir];
  [ms appendString: @",keyOrder:"];
  [ms appendFormat: @"%qi", __keyOrder];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Cursor_open_by_order_result : NSObject <TBase, NSCoding> {
  CursorOpenReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) CursorOpenReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (CursorOpenReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (CursorOpenReply *) success;
- (void) setSuccess: (CursorOpenReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Cursor_open_by_order_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (CursorOpenReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (CursorOpenReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (CursorOpenReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          CursorOpenReply *fieldValue = [[CursorOpenReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Cursor_open_by_order_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Cursor_open_by_order_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface cursor_fetch_args : NSObject <TBase, NSCoding> {
  Session * __session;
  CursorHandle __cursor_handle;

  BOOL __session_isset;
  BOOL __cursor_handle_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, getter=cursor_handle, setter=setCursor_handle:) CursorHandle cursor_handle;
#endif

- (id) init;
- (id) initWithSession: (Session *) session cursor_handle: (CursorHandle) cursor_handle;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (CursorHandle) cursor_handle;
- (void) setCursor_handle: (CursorHandle) cursor_handle;
#endif
- (BOOL) cursor_handleIsSet;

@end

@implementation cursor_fetch_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session cursor_handle: (CursorHandle) cursor_handle
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __cursor_handle = cursor_handle;
  __cursor_handle_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"cursor_handle"])
  {
    __cursor_handle = [decoder decodeInt64ForKey: @"cursor_handle"];
    __cursor_handle_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__cursor_handle_isset)
  {
    [encoder encodeInt64: __cursor_handle forKey: @"cursor_handle"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (int64_t) cursor_handle {
  return __cursor_handle;
}

- (void) setCursor_handle: (int64_t) cursor_handle {
  __cursor_handle = cursor_handle;
  __cursor_handle_isset = YES;
}

- (BOOL) cursor_handleIsSet {
  return __cursor_handle_isset;
}

- (void) unsetCursor_handle {
  __cursor_handle_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCursor_handle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"cursor_fetch_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__cursor_handle_isset) {
    [outProtocol writeFieldBeginWithName: @"cursor_handle" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __cursor_handle];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"cursor_fetch_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",cursor_handle:"];
  [ms appendFormat: @"%qi", __cursor_handle];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Cursor_fetch_result : NSObject <TBase, NSCoding> {
  CursorFetchReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) CursorFetchReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (CursorFetchReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (CursorFetchReply *) success;
- (void) setSuccess: (CursorFetchReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Cursor_fetch_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (CursorFetchReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (CursorFetchReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (CursorFetchReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          CursorFetchReply *fieldValue = [[CursorFetchReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Cursor_fetch_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Cursor_fetch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface cursor_close_args : NSObject <TBase, NSCoding> {
  Session * __session;
  CursorHandle __cursor_handle;

  BOOL __session_isset;
  BOOL __cursor_handle_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=session, setter=setSession:) Session * session;
@property (nonatomic, getter=cursor_handle, setter=setCursor_handle:) CursorHandle cursor_handle;
#endif

- (id) init;
- (id) initWithSession: (Session *) session cursor_handle: (CursorHandle) cursor_handle;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (Session *) session;
- (void) setSession: (Session *) session;
#endif
- (BOOL) sessionIsSet;

#if !__has_feature(objc_arc)
- (CursorHandle) cursor_handle;
- (void) setCursor_handle: (CursorHandle) cursor_handle;
#endif
- (BOOL) cursor_handleIsSet;

@end

@implementation cursor_close_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSession: (Session *) session cursor_handle: (CursorHandle) cursor_handle
{
  self = [super init];
  __session = [session retain_stub];
  __session_isset = YES;
  __cursor_handle = cursor_handle;
  __cursor_handle_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"session"])
  {
    __session = [[decoder decodeObjectForKey: @"session"] retain_stub];
    __session_isset = YES;
  }
  if ([decoder containsValueForKey: @"cursor_handle"])
  {
    __cursor_handle = [decoder decodeInt64ForKey: @"cursor_handle"];
    __cursor_handle_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__session_isset)
  {
    [encoder encodeObject: __session forKey: @"session"];
  }
  if (__cursor_handle_isset)
  {
    [encoder encodeInt64: __cursor_handle forKey: @"cursor_handle"];
  }
}

- (void) dealloc
{
  [__session release_stub];
  [super dealloc_stub];
}

- (Session *) session {
  return [[__session retain_stub] autorelease_stub];
}

- (void) setSession: (Session *) session {
  [session retain_stub];
  [__session release_stub];
  __session = session;
  __session_isset = YES;
}

- (BOOL) sessionIsSet {
  return __session_isset;
}

- (void) unsetSession {
  [__session release_stub];
  __session = nil;
  __session_isset = NO;
}

- (int64_t) cursor_handle {
  return __cursor_handle;
}

- (void) setCursor_handle: (int64_t) cursor_handle {
  __cursor_handle = cursor_handle;
  __cursor_handle_isset = YES;
}

- (BOOL) cursor_handleIsSet {
  return __cursor_handle_isset;
}

- (void) unsetCursor_handle {
  __cursor_handle_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          Session *fieldValue = [[Session alloc] init];
          [fieldValue read: inProtocol];
          [self setSession: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCursor_handle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"cursor_close_args"];
  if (__session_isset) {
    if (__session != nil) {
      [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
      [__session write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__cursor_handle_isset) {
    [outProtocol writeFieldBeginWithName: @"cursor_handle" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __cursor_handle];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"cursor_close_args("];
  [ms appendString: @"session:"];
  [ms appendFormat: @"%@", __session];
  [ms appendString: @",cursor_handle:"];
  [ms appendFormat: @"%qi", __cursor_handle];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Cursor_close_result : NSObject <TBase, NSCoding> {
  DefaultReply * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) DefaultReply * success;
#endif

- (id) init;
- (id) initWithSuccess: (DefaultReply *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (DefaultReply *) success;
- (void) setSuccess: (DefaultReply *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation Cursor_close_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (DefaultReply *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (DefaultReply *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (DefaultReply *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          DefaultReply *fieldValue = [[DefaultReply alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Cursor_close_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Cursor_close_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation DatabaseServiceClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  self = [super init];
  inProtocol = [anInProtocol retain_stub];
  outProtocol = [anOutProtocol retain_stub];
  return self;
}

- (void) dealloc
{
  [inProtocol release_stub];
  [outProtocol release_stub];
  [super dealloc_stub];
}

- (void) send_connect
{
  [outProtocol writeMessageBeginWithName: @"connect" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"connect_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (ConnectReply *) recv_connect
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Connect_result * result = [[[Connect_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"connect failed: unknown result"];
}

- (ConnectReply *) connect
{
  [self send_connect];
  return [self recv_connect];
}

- (void) send_disconnect: (Session *) session
{
  [outProtocol writeMessageBeginWithName: @"disconnect" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"disconnect_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_disconnect
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Disconnect_result * result = [[[Disconnect_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"disconnect failed: unknown result"];
}

- (DefaultReply *) disconnect: (Session *) session
{
  [self send_disconnect : session];
  return [self recv_disconnect];
}

- (void) send_database_create: (Session *) session db_name: (NSString *) db_name
{
  [outProtocol writeMessageBeginWithName: @"database_create" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"database_create_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (db_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"db_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: db_name];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_database_create
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Database_create_result * result = [[[Database_create_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"database_create failed: unknown result"];
}

- (DefaultReply *) database_create: (Session *) session db_name: (NSString *) db_name
{
  [self send_database_create : session db_name: db_name];
  return [self recv_database_create];
}

- (void) send_database_drop: (Session *) session db_name: (NSString *) db_name
{
  [outProtocol writeMessageBeginWithName: @"database_drop" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"database_drop_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (db_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"db_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: db_name];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_database_drop
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Database_drop_result * result = [[[Database_drop_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"database_drop failed: unknown result"];
}

- (DefaultReply *) database_drop: (Session *) session db_name: (NSString *) db_name
{
  [self send_database_drop : session db_name: db_name];
  return [self recv_database_drop];
}

- (void) send_database_use: (Session *) session db_name: (NSString *) db_name
{
  [outProtocol writeMessageBeginWithName: @"database_use" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"database_use_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (db_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"db_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: db_name];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_database_use
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Database_use_result * result = [[[Database_use_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"database_use failed: unknown result"];
}

- (DefaultReply *) database_use: (Session *) session db_name: (NSString *) db_name
{
  [self send_database_use : session db_name: db_name];
  return [self recv_database_use];
}

- (void) send_table_create: (Session *) session table_name: (NSString *) table_name
{
  [outProtocol writeMessageBeginWithName: @"table_create" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"table_create_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (table_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: table_name];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_table_create
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Table_create_result * result = [[[Table_create_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"table_create failed: unknown result"];
}

- (DefaultReply *) table_create: (Session *) session table_name: (NSString *) table_name
{
  [self send_table_create : session table_name: table_name];
  return [self recv_table_create];
}

- (void) send_table_drop: (Session *) session table_name: (NSString *) table_name
{
  [outProtocol writeMessageBeginWithName: @"table_drop" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"table_drop_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (table_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: table_name];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_table_drop
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Table_drop_result * result = [[[Table_drop_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"table_drop failed: unknown result"];
}

- (DefaultReply *) table_drop: (Session *) session table_name: (NSString *) table_name
{
  [self send_table_drop : session table_name: table_name];
  return [self recv_table_drop];
}

- (void) send_table_stat: (Session *) session table_name: (NSString *) table_name
{
  [outProtocol writeMessageBeginWithName: @"table_stat" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"table_stat_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (table_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: table_name];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (TableStatReply *) recv_table_stat
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Table_stat_result * result = [[[Table_stat_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"table_stat failed: unknown result"];
}

- (TableStatReply *) table_stat: (Session *) session table_name: (NSString *) table_name
{
  [self send_table_stat : session table_name: table_name];
  return [self recv_table_stat];
}

- (void) send_table_put: (Session *) session table_name: (NSString *) table_name key: (NSData *) key value: (NSData *) value
{
  [outProtocol writeMessageBeginWithName: @"table_put" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"table_put_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (table_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: table_name];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeBinary: key];
    [outProtocol writeFieldEnd];
  }
  if (value != nil)  {
    [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
    [outProtocol writeBinary: value];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_table_put
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Table_put_result * result = [[[Table_put_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"table_put failed: unknown result"];
}

- (DefaultReply *) table_put: (Session *) session table_name: (NSString *) table_name key: (NSData *) key value: (NSData *) value
{
  [self send_table_put : session table_name: table_name key: key value: value];
  return [self recv_table_put];
}

- (void) send_table_get_by_key: (Session *) session table_name: (NSString *) table_name key: (NSData *) key
{
  [outProtocol writeMessageBeginWithName: @"table_get_by_key" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"table_get_by_key_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (table_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: table_name];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeBinary: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (TableGetReply *) recv_table_get_by_key
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Table_get_by_key_result * result = [[[Table_get_by_key_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"table_get_by_key failed: unknown result"];
}

- (TableGetReply *) table_get_by_key: (Session *) session table_name: (NSString *) table_name key: (NSData *) key
{
  [self send_table_get_by_key : session table_name: table_name key: key];
  return [self recv_table_get_by_key];
}

- (void) send_table_get_by_order: (Session *) session table_name: (NSString *) table_name keyOrder: (KeyOrder) keyOrder
{
  [outProtocol writeMessageBeginWithName: @"table_get_by_order" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"table_get_by_order_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (table_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: table_name];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"keyOrder" type: TType_I64 fieldID: 3];
  [outProtocol writeI64: keyOrder];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (TableGetReply *) recv_table_get_by_order
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Table_get_by_order_result * result = [[[Table_get_by_order_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"table_get_by_order failed: unknown result"];
}

- (TableGetReply *) table_get_by_order: (Session *) session table_name: (NSString *) table_name keyOrder: (KeyOrder) keyOrder
{
  [self send_table_get_by_order : session table_name: table_name keyOrder: keyOrder];
  return [self recv_table_get_by_order];
}

- (void) send_table_del: (Session *) session table_name: (NSString *) table_name key: (NSData *) key
{
  [outProtocol writeMessageBeginWithName: @"table_del" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"table_del_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (table_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: table_name];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeBinary: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_table_del
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Table_del_result * result = [[[Table_del_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"table_del failed: unknown result"];
}

- (DefaultReply *) table_del: (Session *) session table_name: (NSString *) table_name key: (NSData *) key
{
  [self send_table_del : session table_name: table_name key: key];
  return [self recv_table_del];
}

- (void) send_transaction_begin: (Session *) session
{
  [outProtocol writeMessageBeginWithName: @"transaction_begin" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"transaction_begin_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_transaction_begin
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Transaction_begin_result * result = [[[Transaction_begin_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"transaction_begin failed: unknown result"];
}

- (DefaultReply *) transaction_begin: (Session *) session
{
  [self send_transaction_begin : session];
  return [self recv_transaction_begin];
}

- (void) send_transaction_abort: (Session *) session
{
  [outProtocol writeMessageBeginWithName: @"transaction_abort" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"transaction_abort_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_transaction_abort
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Transaction_abort_result * result = [[[Transaction_abort_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"transaction_abort failed: unknown result"];
}

- (DefaultReply *) transaction_abort: (Session *) session
{
  [self send_transaction_abort : session];
  return [self recv_transaction_abort];
}

- (void) send_transaction_commit: (Session *) session
{
  [outProtocol writeMessageBeginWithName: @"transaction_commit" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"transaction_commit_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_transaction_commit
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Transaction_commit_result * result = [[[Transaction_commit_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"transaction_commit failed: unknown result"];
}

- (DefaultReply *) transaction_commit: (Session *) session
{
  [self send_transaction_commit : session];
  return [self recv_transaction_commit];
}

- (void) send_cursor_open_by_key: (Session *) session table_name: (NSString *) table_name dir: (int) dir key: (NSData *) key
{
  [outProtocol writeMessageBeginWithName: @"cursor_open_by_key" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"cursor_open_by_key_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (table_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: table_name];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"dir" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: dir];
  [outProtocol writeFieldEnd];
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 4];
    [outProtocol writeBinary: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (CursorOpenReply *) recv_cursor_open_by_key
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Cursor_open_by_key_result * result = [[[Cursor_open_by_key_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"cursor_open_by_key failed: unknown result"];
}

- (CursorOpenReply *) cursor_open_by_key: (Session *) session table_name: (NSString *) table_name dir: (int) dir key: (NSData *) key
{
  [self send_cursor_open_by_key : session table_name: table_name dir: dir key: key];
  return [self recv_cursor_open_by_key];
}

- (void) send_cursor_open_by_order: (Session *) session table_name: (NSString *) table_name dir: (int) dir keyOrder: (KeyOrder) keyOrder
{
  [outProtocol writeMessageBeginWithName: @"cursor_open_by_order" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"cursor_open_by_order_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (table_name != nil)  {
    [outProtocol writeFieldBeginWithName: @"table_name" type: TType_STRING fieldID: 2];
    [outProtocol writeString: table_name];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"dir" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: dir];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"keyOrder" type: TType_I64 fieldID: 4];
  [outProtocol writeI64: keyOrder];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (CursorOpenReply *) recv_cursor_open_by_order
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Cursor_open_by_order_result * result = [[[Cursor_open_by_order_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"cursor_open_by_order failed: unknown result"];
}

- (CursorOpenReply *) cursor_open_by_order: (Session *) session table_name: (NSString *) table_name dir: (int) dir keyOrder: (KeyOrder) keyOrder
{
  [self send_cursor_open_by_order : session table_name: table_name dir: dir keyOrder: keyOrder];
  return [self recv_cursor_open_by_order];
}

- (void) send_cursor_fetch: (Session *) session cursor_handle: (CursorHandle) cursor_handle
{
  [outProtocol writeMessageBeginWithName: @"cursor_fetch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"cursor_fetch_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"cursor_handle" type: TType_I64 fieldID: 2];
  [outProtocol writeI64: cursor_handle];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (CursorFetchReply *) recv_cursor_fetch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Cursor_fetch_result * result = [[[Cursor_fetch_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"cursor_fetch failed: unknown result"];
}

- (CursorFetchReply *) cursor_fetch: (Session *) session cursor_handle: (CursorHandle) cursor_handle
{
  [self send_cursor_fetch : session cursor_handle: cursor_handle];
  return [self recv_cursor_fetch];
}

- (void) send_cursor_close: (Session *) session cursor_handle: (CursorHandle) cursor_handle
{
  [outProtocol writeMessageBeginWithName: @"cursor_close" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"cursor_close_args"];
  if (session != nil)  {
    [outProtocol writeFieldBeginWithName: @"session" type: TType_STRUCT fieldID: 1];
    [session write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"cursor_handle" type: TType_I64 fieldID: 2];
  [outProtocol writeI64: cursor_handle];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (DefaultReply *) recv_cursor_close
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Cursor_close_result * result = [[[Cursor_close_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"cursor_close failed: unknown result"];
}

- (DefaultReply *) cursor_close: (Session *) session cursor_handle: (CursorHandle) cursor_handle
{
  [self send_cursor_close : session cursor_handle: cursor_handle];
  return [self recv_cursor_close];
}

@end

@implementation DatabaseServiceProcessor

- (id) initWithDatabaseService: (id <DatabaseService>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain_stub];
  mMethodMap = [[NSMutableDictionary dictionary] retain_stub];
  {
    SEL s = @selector(process_connect_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"connect"];
  }
  {
    SEL s = @selector(process_disconnect_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"disconnect"];
  }
  {
    SEL s = @selector(process_database_create_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"database_create"];
  }
  {
    SEL s = @selector(process_database_drop_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"database_drop"];
  }
  {
    SEL s = @selector(process_database_use_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"database_use"];
  }
  {
    SEL s = @selector(process_table_create_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"table_create"];
  }
  {
    SEL s = @selector(process_table_drop_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"table_drop"];
  }
  {
    SEL s = @selector(process_table_stat_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"table_stat"];
  }
  {
    SEL s = @selector(process_table_put_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"table_put"];
  }
  {
    SEL s = @selector(process_table_get_by_key_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"table_get_by_key"];
  }
  {
    SEL s = @selector(process_table_get_by_order_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"table_get_by_order"];
  }
  {
    SEL s = @selector(process_table_del_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"table_del"];
  }
  {
    SEL s = @selector(process_transaction_begin_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"transaction_begin"];
  }
  {
    SEL s = @selector(process_transaction_abort_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"transaction_abort"];
  }
  {
    SEL s = @selector(process_transaction_commit_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"transaction_commit"];
  }
  {
    SEL s = @selector(process_cursor_open_by_key_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"cursor_open_by_key"];
  }
  {
    SEL s = @selector(process_cursor_open_by_order_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"cursor_open_by_order"];
  }
  {
    SEL s = @selector(process_cursor_fetch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"cursor_fetch"];
  }
  {
    SEL s = @selector(process_cursor_close_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"cursor_close"];
  }
  return self;
}

- (id<DatabaseService>) service
{
  return [[mService retain_stub] autorelease_stub];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_connect_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  connect_args * args = [[connect_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Connect_result * result = [[Connect_result alloc] init];
  [result setSuccess: [mService connect]];
  [outProtocol writeMessageBeginWithName: @"connect"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_disconnect_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  disconnect_args * args = [[disconnect_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Disconnect_result * result = [[Disconnect_result alloc] init];
  [result setSuccess: [mService disconnect: [args session]]];
  [outProtocol writeMessageBeginWithName: @"disconnect"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_database_create_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  database_create_args * args = [[database_create_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Database_create_result * result = [[Database_create_result alloc] init];
  [result setSuccess: [mService database_create: [args session] db_name: [args db_name]]];
  [outProtocol writeMessageBeginWithName: @"database_create"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_database_drop_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  database_drop_args * args = [[database_drop_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Database_drop_result * result = [[Database_drop_result alloc] init];
  [result setSuccess: [mService database_drop: [args session] db_name: [args db_name]]];
  [outProtocol writeMessageBeginWithName: @"database_drop"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_database_use_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  database_use_args * args = [[database_use_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Database_use_result * result = [[Database_use_result alloc] init];
  [result setSuccess: [mService database_use: [args session] db_name: [args db_name]]];
  [outProtocol writeMessageBeginWithName: @"database_use"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_table_create_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  table_create_args * args = [[table_create_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Table_create_result * result = [[Table_create_result alloc] init];
  [result setSuccess: [mService table_create: [args session] table_name: [args table_name]]];
  [outProtocol writeMessageBeginWithName: @"table_create"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_table_drop_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  table_drop_args * args = [[table_drop_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Table_drop_result * result = [[Table_drop_result alloc] init];
  [result setSuccess: [mService table_drop: [args session] table_name: [args table_name]]];
  [outProtocol writeMessageBeginWithName: @"table_drop"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_table_stat_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  table_stat_args * args = [[table_stat_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Table_stat_result * result = [[Table_stat_result alloc] init];
  [result setSuccess: [mService table_stat: [args session] table_name: [args table_name]]];
  [outProtocol writeMessageBeginWithName: @"table_stat"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_table_put_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  table_put_args * args = [[table_put_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Table_put_result * result = [[Table_put_result alloc] init];
  [result setSuccess: [mService table_put: [args session] table_name: [args table_name] key: [args key] value: [args value]]];
  [outProtocol writeMessageBeginWithName: @"table_put"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_table_get_by_key_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  table_get_by_key_args * args = [[table_get_by_key_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Table_get_by_key_result * result = [[Table_get_by_key_result alloc] init];
  [result setSuccess: [mService table_get_by_key: [args session] table_name: [args table_name] key: [args key]]];
  [outProtocol writeMessageBeginWithName: @"table_get_by_key"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_table_get_by_order_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  table_get_by_order_args * args = [[table_get_by_order_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Table_get_by_order_result * result = [[Table_get_by_order_result alloc] init];
  [result setSuccess: [mService table_get_by_order: [args session] table_name: [args table_name] keyOrder: [args keyOrder]]];
  [outProtocol writeMessageBeginWithName: @"table_get_by_order"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_table_del_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  table_del_args * args = [[table_del_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Table_del_result * result = [[Table_del_result alloc] init];
  [result setSuccess: [mService table_del: [args session] table_name: [args table_name] key: [args key]]];
  [outProtocol writeMessageBeginWithName: @"table_del"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_transaction_begin_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  transaction_begin_args * args = [[transaction_begin_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Transaction_begin_result * result = [[Transaction_begin_result alloc] init];
  [result setSuccess: [mService transaction_begin: [args session]]];
  [outProtocol writeMessageBeginWithName: @"transaction_begin"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_transaction_abort_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  transaction_abort_args * args = [[transaction_abort_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Transaction_abort_result * result = [[Transaction_abort_result alloc] init];
  [result setSuccess: [mService transaction_abort: [args session]]];
  [outProtocol writeMessageBeginWithName: @"transaction_abort"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_transaction_commit_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  transaction_commit_args * args = [[transaction_commit_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Transaction_commit_result * result = [[Transaction_commit_result alloc] init];
  [result setSuccess: [mService transaction_commit: [args session]]];
  [outProtocol writeMessageBeginWithName: @"transaction_commit"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_cursor_open_by_key_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  cursor_open_by_key_args * args = [[cursor_open_by_key_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Cursor_open_by_key_result * result = [[Cursor_open_by_key_result alloc] init];
  [result setSuccess: [mService cursor_open_by_key: [args session] table_name: [args table_name] dir: [args dir] key: [args key]]];
  [outProtocol writeMessageBeginWithName: @"cursor_open_by_key"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_cursor_open_by_order_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  cursor_open_by_order_args * args = [[cursor_open_by_order_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Cursor_open_by_order_result * result = [[Cursor_open_by_order_result alloc] init];
  [result setSuccess: [mService cursor_open_by_order: [args session] table_name: [args table_name] dir: [args dir] keyOrder: [args keyOrder]]];
  [outProtocol writeMessageBeginWithName: @"cursor_open_by_order"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_cursor_fetch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  cursor_fetch_args * args = [[cursor_fetch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Cursor_fetch_result * result = [[Cursor_fetch_result alloc] init];
  [result setSuccess: [mService cursor_fetch: [args session] cursor_handle: [args cursor_handle]]];
  [outProtocol writeMessageBeginWithName: @"cursor_fetch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_cursor_close_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  cursor_close_args * args = [[cursor_close_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Cursor_close_result * result = [[Cursor_close_result alloc] init];
  [result setSuccess: [mService cursor_close: [args session] cursor_handle: [args cursor_handle]]];
  [outProtocol writeMessageBeginWithName: @"cursor_close"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) dealloc
{
  [mService release_stub];
  [mMethodMap release_stub];
  [super dealloc_stub];
}

@end

