/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "DatabaseService_types.h"

#include <algorithm>

namespace nanolat { namespace thrift {

int _kErrorCodeValues[] = {
  ErrorCode::NL_SUCCESS,
  ErrorCode::NL_ERROR_CODE_START,
  ErrorCode::NL_FAILURE,
  ErrorCode::NL_INVALID_ARGUMENT,
  ErrorCode::NL_INVALID_SESSION_HANDLE,
  ErrorCode::NL_INVALID_CURSOR_HANDLE,
  ErrorCode::NL_TRANSACTION_ALREADY_BEGAN,
  ErrorCode::NL_NO_TRANSACTION_BEGAN,
  ErrorCode::NL_DATABASE_ALREADY_EXISTS,
  ErrorCode::NL_DATABASE_DOES_NOT_EXIST,
  ErrorCode::NL_DATABASE_ALREADY_OPEN,
  ErrorCode::NL_DATABASE_NOT_OPEN,
  ErrorCode::NL_TABLE_ALREADY_EXISTS,
  ErrorCode::NL_TABLE_DOES_NOT_EXIST,
  ErrorCode::NL_TABLE_ALREADY_OPEN,
  ErrorCode::NL_TABLE_NOT_OPEN,
  ErrorCode::NL_CURSOR_HAS_NO_MORE_KEYS,
  ErrorCode::NL_ERROR_CODE_END
};
const char* _kErrorCodeNames[] = {
  "NL_SUCCESS",
  "NL_ERROR_CODE_START",
  "NL_FAILURE",
  "NL_INVALID_ARGUMENT",
  "NL_INVALID_SESSION_HANDLE",
  "NL_INVALID_CURSOR_HANDLE",
  "NL_TRANSACTION_ALREADY_BEGAN",
  "NL_NO_TRANSACTION_BEGAN",
  "NL_DATABASE_ALREADY_EXISTS",
  "NL_DATABASE_DOES_NOT_EXIST",
  "NL_DATABASE_ALREADY_OPEN",
  "NL_DATABASE_NOT_OPEN",
  "NL_TABLE_ALREADY_EXISTS",
  "NL_TABLE_DOES_NOT_EXIST",
  "NL_TABLE_ALREADY_OPEN",
  "NL_TABLE_NOT_OPEN",
  "NL_CURSOR_HAS_NO_MORE_KEYS",
  "NL_ERROR_CODE_END"
};
const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(18, _kErrorCodeValues, _kErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCursorDirectionValues[] = {
  CursorDirection::CD_FORWARD,
  CursorDirection::CD_BACKWARD
};
const char* _kCursorDirectionNames[] = {
  "CD_FORWARD",
  "CD_BACKWARD"
};
const std::map<int, const char*> _CursorDirection_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCursorDirectionValues, _kCursorDirectionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* ReplyStatus::ascii_fingerprint = "D121591FCC85D0E17C727CA264A5F46D";
const uint8_t ReplyStatus::binary_fingerprint[16] = {0xD1,0x21,0x59,0x1F,0xCC,0x85,0xD0,0xE1,0x7C,0x72,0x7C,0xA2,0x64,0xA5,0xF4,0x6D};

uint32_t ReplyStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->error_code = (ErrorCode::type)ecast0;
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_message_format);
          this->__isset.error_message_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->error_message_args.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            xfer += iprot->readListBegin(_etype4, _size1);
            this->error_message_args.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              xfer += iprot->readString(this->error_message_args[_i5]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.error_message_args = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReplyStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReplyStatus");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_message_format", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_message_format);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_message_args", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->error_message_args.size()));
    std::vector<std::string> ::const_iterator _iter6;
    for (_iter6 = this->error_message_args.begin(); _iter6 != this->error_message_args.end(); ++_iter6)
    {
      xfer += oprot->writeString((*_iter6));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplyStatus &a, ReplyStatus &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_message_format, b.error_message_format);
  swap(a.error_message_args, b.error_message_args);
  swap(a.__isset, b.__isset);
}

const char* DefaultReply::ascii_fingerprint = "F6AD8D6EE2A97B9BAFE986CBB5A33301";
const uint8_t DefaultReply::binary_fingerprint[16] = {0xF6,0xAD,0x8D,0x6E,0xE2,0xA9,0x7B,0x9B,0xAF,0xE9,0x86,0xCB,0xB5,0xA3,0x33,0x01};

uint32_t DefaultReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DefaultReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DefaultReply");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DefaultReply &a, DefaultReply &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* TableGetReply::ascii_fingerprint = "12DB6D4F4F476E98279922C0151BCE9D";
const uint8_t TableGetReply::binary_fingerprint[16] = {0x12,0xDB,0x6D,0x4F,0x4F,0x47,0x6E,0x98,0x27,0x99,0x22,0xC0,0x15,0x1B,0xCE,0x9D};

uint32_t TableGetReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->key_order);
          this->__isset.key_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableGetReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TableGetReply");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_order", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->key_order);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableGetReply &a, TableGetReply &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.key_order, b.key_order);
  swap(a.__isset, b.__isset);
}

const char* TableStatReply::ascii_fingerprint = "297ADE62C268099DB94D4911AFABFAD2";
const uint8_t TableStatReply::binary_fingerprint[16] = {0x29,0x7A,0xDE,0x62,0xC2,0x68,0x09,0x9D,0xB9,0x4D,0x49,0x11,0xAF,0xAB,0xFA,0xD2};

uint32_t TableStatReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->key_count);
          this->__isset.key_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableStatReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TableStatReply");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->key_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableStatReply &a, TableStatReply &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.key_count, b.key_count);
  swap(a.__isset, b.__isset);
}

const char* CursorOpenReply::ascii_fingerprint = "297ADE62C268099DB94D4911AFABFAD2";
const uint8_t CursorOpenReply::binary_fingerprint[16] = {0x29,0x7A,0xDE,0x62,0xC2,0x68,0x09,0x9D,0xB9,0x4D,0x49,0x11,0xAF,0xAB,0xFA,0xD2};

uint32_t CursorOpenReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cursor_handle);
          this->__isset.cursor_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CursorOpenReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CursorOpenReply");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cursor_handle", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cursor_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CursorOpenReply &a, CursorOpenReply &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.cursor_handle, b.cursor_handle);
  swap(a.__isset, b.__isset);
}

const char* CursorFetchReply::ascii_fingerprint = "934F0AEE7F208CE86DDE03BD9134FEE7";
const uint8_t CursorFetchReply::binary_fingerprint[16] = {0x93,0x4F,0x0A,0xEE,0x7F,0x20,0x8C,0xE8,0x6D,0xDE,0x03,0xBD,0x91,0x34,0xFE,0xE7};

uint32_t CursorFetchReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->key_order);
          this->__isset.key_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CursorFetchReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CursorFetchReply");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_order", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->key_order);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CursorFetchReply &a, CursorFetchReply &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.key, b.key);
  swap(a.key_order, b.key_order);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* Session::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t Session::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t Session::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->session_handle);
          this->__isset.session_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Session::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Session");

  xfer += oprot->writeFieldBegin("session_handle", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->session_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Session &a, Session &b) {
  using ::std::swap;
  swap(a.session_handle, b.session_handle);
  swap(a.__isset, b.__isset);
}

const char* ConnectReply::ascii_fingerprint = "EF7726327C200A5474DB445BFBEE48E9";
const uint8_t ConnectReply::binary_fingerprint[16] = {0xEF,0x77,0x26,0x32,0x7C,0x20,0x0A,0x54,0x74,0xDB,0x44,0x5B,0xFB,0xEE,0x48,0xE9};

uint32_t ConnectReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->session_handle);
          this->__isset.session_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConnectReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConnectReply");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_handle", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->session_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConnectReply &a, ConnectReply &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.session_handle, b.session_handle);
  swap(a.__isset, b.__isset);
}

}} // namespace
