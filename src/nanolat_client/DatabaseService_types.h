/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DatabaseService_TYPES_H
#define DatabaseService_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace nanolat { namespace thrift {

struct ErrorCode {
  enum type {
    NL_SUCCESS = 0,
    NL_ERROR_CODE_START = -1000,
    NL_FAILURE = -1000,
    NL_INVALID_ARGUMENT = -1001,
    NL_INVALID_SESSION_HANDLE = -1002,
    NL_INVALID_CURSOR_HANDLE = -1003,
    NL_TRANSACTION_ALREADY_BEGAN = -1004,
    NL_NO_TRANSACTION_BEGAN = -1005,
    NL_DATABASE_ALREADY_EXISTS = -1006,
    NL_DATABASE_DOES_NOT_EXIST = -1007,
    NL_DATABASE_ALREADY_OPEN = -1008,
    NL_DATABASE_NOT_OPEN = -1009,
    NL_TABLE_ALREADY_EXISTS = -1010,
    NL_TABLE_DOES_NOT_EXIST = -1011,
    NL_TABLE_ALREADY_OPEN = -1012,
    NL_TABLE_NOT_OPEN = -1013,
    NL_CURSOR_HAS_NO_MORE_KEYS = -1014,
    NL_INCOMPATIBLE_CLINET_VERSION = -1015,
    NL_ERROR_CODE_END = -1015
  };
};

extern const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES;

struct CursorDirection {
  enum type {
    CD_FORWARD = 1,
    CD_BACKWARD = 2
  };
};

extern const std::map<int, const char*> _CursorDirection_VALUES_TO_NAMES;

typedef int64_t KeyOrder;

typedef int64_t CursorHandle;

typedef struct _ReplyStatus__isset {
  _ReplyStatus__isset() : error_code(false), error_message_format(false), error_message_args(false) {}
  bool error_code;
  bool error_message_format;
  bool error_message_args;
} _ReplyStatus__isset;

class ReplyStatus {
 public:

  static const char* ascii_fingerprint; // = "D121591FCC85D0E17C727CA264A5F46D";
  static const uint8_t binary_fingerprint[16]; // = {0xD1,0x21,0x59,0x1F,0xCC,0x85,0xD0,0xE1,0x7C,0x72,0x7C,0xA2,0x64,0xA5,0xF4,0x6D};

  ReplyStatus() : error_code((ErrorCode::type)0), error_message_format() {
  }

  virtual ~ReplyStatus() throw() {}

  ErrorCode::type error_code;
  std::string error_message_format;
  std::vector<std::string>  error_message_args;

  _ReplyStatus__isset __isset;

  void __set_error_code(const ErrorCode::type val) {
    error_code = val;
  }

  void __set_error_message_format(const std::string& val) {
    error_message_format = val;
  }

  void __set_error_message_args(const std::vector<std::string> & val) {
    error_message_args = val;
  }

  bool operator == (const ReplyStatus & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    if (!(error_message_format == rhs.error_message_format))
      return false;
    if (!(error_message_args == rhs.error_message_args))
      return false;
    return true;
  }
  bool operator != (const ReplyStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplyStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ReplyStatus &a, ReplyStatus &b);

typedef struct _DefaultReply__isset {
  _DefaultReply__isset() : status(false) {}
  bool status;
} _DefaultReply__isset;

class DefaultReply {
 public:

  static const char* ascii_fingerprint; // = "F6AD8D6EE2A97B9BAFE986CBB5A33301";
  static const uint8_t binary_fingerprint[16]; // = {0xF6,0xAD,0x8D,0x6E,0xE2,0xA9,0x7B,0x9B,0xAF,0xE9,0x86,0xCB,0xB5,0xA3,0x33,0x01};

  DefaultReply() {
  }

  virtual ~DefaultReply() throw() {}

  ReplyStatus status;

  _DefaultReply__isset __isset;

  void __set_status(const ReplyStatus& val) {
    status = val;
  }

  bool operator == (const DefaultReply & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const DefaultReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DefaultReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DefaultReply &a, DefaultReply &b);

typedef struct _TableGetReply__isset {
  _TableGetReply__isset() : status(false), key(false), value(false), key_order(false) {}
  bool status;
  bool key;
  bool value;
  bool key_order;
} _TableGetReply__isset;

class TableGetReply {
 public:

  static const char* ascii_fingerprint; // = "12DB6D4F4F476E98279922C0151BCE9D";
  static const uint8_t binary_fingerprint[16]; // = {0x12,0xDB,0x6D,0x4F,0x4F,0x47,0x6E,0x98,0x27,0x99,0x22,0xC0,0x15,0x1B,0xCE,0x9D};

  TableGetReply() : key(), value(), key_order(0) {
  }

  virtual ~TableGetReply() throw() {}

  ReplyStatus status;
  std::string key;
  std::string value;
  KeyOrder key_order;

  _TableGetReply__isset __isset;

  void __set_status(const ReplyStatus& val) {
    status = val;
  }

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_key_order(const KeyOrder val) {
    key_order = val;
  }

  bool operator == (const TableGetReply & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(key_order == rhs.key_order))
      return false;
    return true;
  }
  bool operator != (const TableGetReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableGetReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TableGetReply &a, TableGetReply &b);

typedef struct _TableStatReply__isset {
  _TableStatReply__isset() : status(false), key_count(false) {}
  bool status;
  bool key_count;
} _TableStatReply__isset;

class TableStatReply {
 public:

  static const char* ascii_fingerprint; // = "297ADE62C268099DB94D4911AFABFAD2";
  static const uint8_t binary_fingerprint[16]; // = {0x29,0x7A,0xDE,0x62,0xC2,0x68,0x09,0x9D,0xB9,0x4D,0x49,0x11,0xAF,0xAB,0xFA,0xD2};

  TableStatReply() : key_count(0) {
  }

  virtual ~TableStatReply() throw() {}

  ReplyStatus status;
  KeyOrder key_count;

  _TableStatReply__isset __isset;

  void __set_status(const ReplyStatus& val) {
    status = val;
  }

  void __set_key_count(const KeyOrder val) {
    key_count = val;
  }

  bool operator == (const TableStatReply & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(key_count == rhs.key_count))
      return false;
    return true;
  }
  bool operator != (const TableStatReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableStatReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TableStatReply &a, TableStatReply &b);

typedef struct _CursorOpenReply__isset {
  _CursorOpenReply__isset() : status(false), cursor_handle(false) {}
  bool status;
  bool cursor_handle;
} _CursorOpenReply__isset;

class CursorOpenReply {
 public:

  static const char* ascii_fingerprint; // = "297ADE62C268099DB94D4911AFABFAD2";
  static const uint8_t binary_fingerprint[16]; // = {0x29,0x7A,0xDE,0x62,0xC2,0x68,0x09,0x9D,0xB9,0x4D,0x49,0x11,0xAF,0xAB,0xFA,0xD2};

  CursorOpenReply() : cursor_handle(0) {
  }

  virtual ~CursorOpenReply() throw() {}

  ReplyStatus status;
  CursorHandle cursor_handle;

  _CursorOpenReply__isset __isset;

  void __set_status(const ReplyStatus& val) {
    status = val;
  }

  void __set_cursor_handle(const CursorHandle val) {
    cursor_handle = val;
  }

  bool operator == (const CursorOpenReply & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(cursor_handle == rhs.cursor_handle))
      return false;
    return true;
  }
  bool operator != (const CursorOpenReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CursorOpenReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CursorOpenReply &a, CursorOpenReply &b);

typedef struct _CursorFetchReply__isset {
  _CursorFetchReply__isset() : status(false), key(false), key_order(false), value(false) {}
  bool status;
  bool key;
  bool key_order;
  bool value;
} _CursorFetchReply__isset;

class CursorFetchReply {
 public:

  static const char* ascii_fingerprint; // = "934F0AEE7F208CE86DDE03BD9134FEE7";
  static const uint8_t binary_fingerprint[16]; // = {0x93,0x4F,0x0A,0xEE,0x7F,0x20,0x8C,0xE8,0x6D,0xDE,0x03,0xBD,0x91,0x34,0xFE,0xE7};

  CursorFetchReply() : key(), key_order(0), value() {
  }

  virtual ~CursorFetchReply() throw() {}

  ReplyStatus status;
  std::string key;
  KeyOrder key_order;
  std::string value;

  _CursorFetchReply__isset __isset;

  void __set_status(const ReplyStatus& val) {
    status = val;
  }

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_key_order(const KeyOrder val) {
    key_order = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const CursorFetchReply & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(key_order == rhs.key_order))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const CursorFetchReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CursorFetchReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CursorFetchReply &a, CursorFetchReply &b);

typedef struct _Session__isset {
  _Session__isset() : session_handle(false) {}
  bool session_handle;
} _Session__isset;

class Session {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  Session() : session_handle(0) {
  }

  virtual ~Session() throw() {}

  int32_t session_handle;

  _Session__isset __isset;

  void __set_session_handle(const int32_t val) {
    session_handle = val;
  }

  bool operator == (const Session & rhs) const
  {
    if (!(session_handle == rhs.session_handle))
      return false;
    return true;
  }
  bool operator != (const Session &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Session & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Session &a, Session &b);

typedef struct _ConnectReply__isset {
  _ConnectReply__isset() : status(false), session_handle(false) {}
  bool status;
  bool session_handle;
} _ConnectReply__isset;

class ConnectReply {
 public:

  static const char* ascii_fingerprint; // = "EF7726327C200A5474DB445BFBEE48E9";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0x77,0x26,0x32,0x7C,0x20,0x0A,0x54,0x74,0xDB,0x44,0x5B,0xFB,0xEE,0x48,0xE9};

  ConnectReply() : session_handle(0) {
  }

  virtual ~ConnectReply() throw() {}

  ReplyStatus status;
  int32_t session_handle;

  _ConnectReply__isset __isset;

  void __set_status(const ReplyStatus& val) {
    status = val;
  }

  void __set_session_handle(const int32_t val) {
    session_handle = val;
  }

  bool operator == (const ConnectReply & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(session_handle == rhs.session_handle))
      return false;
    return true;
  }
  bool operator != (const ConnectReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ConnectReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ConnectReply &a, ConnectReply &b);

}} // namespace

#endif
